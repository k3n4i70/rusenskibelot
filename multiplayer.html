<!DOCTYPE html>
<html lang="bg">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Белот Русе P2P (Демо v7.1 - Пълен Код с Мултиплейър)</title>
    <style>
        /* --- Основни Стилове --- */
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; background-color: #f0f0f0; margin: 0; padding: 10px; min-height: 100vh; box-sizing: border-box; }
        .game-container { background-color: #2a6a2a; border: 5px solid #5d3a1a; border-radius: 10px; padding: 15px; width: 95%; max-width: 800px; box-shadow: 0 0 15px rgba(0, 0, 0, 0.5); position: relative; aspect-ratio: 4 / 3; display: flex; flex-direction: column; justify-content: space-between; overflow: hidden; }
        .persistent-trump { position: absolute; top: 10px; right: 10px; background-color: rgba(0, 0, 0, 0.6); color: white; padding: 5px 10px; border-radius: 5px; font-size: 0.9em; z-index: 50; text-align: right; max-width: 150px; }
        .persistent-trump .suit { font-size: 1.3em; font-weight: bold; }
        .persistent-trump .suit.spades, .persistent-trump .suit.clubs { color: white; text-shadow: 1px 1px 1px black; }
        .persistent-trump .suit.hearts, .persistent-trump .suit.diamonds { color: #ffcccc; text-shadow: 1px 1px 1px darkred; }
        .player-area { display: flex; align-items: center; position: absolute; min-width: 80px; min-height: 70px; background: rgba(255, 255, 255, 0.1); border-radius: 5px; padding: 5px; transition: box-shadow 0.3s ease; z-index: 20; }
        .player-area.current-player { box-shadow: 0 0 15px 5px yellow; }
        .player-south { bottom: 10px; left: 50%; transform: translateX(-50%); flex-direction: column; align-items: center; width: 80%; }
        .player-west { left: 10px; top: 50%; transform: translateY(-50%); flex-direction: column; align-items: flex-start; }
        .player-north { top: 10px; left: 50%; transform: translateX(-50%); flex-direction: column-reverse; align-items: center; }
        .player-east { right: 10px; top: 50%; transform: translateY(-50%); flex-direction: column; align-items: flex-end; }
        .player-name { font-weight: bold; color: white; margin-bottom: 5px; font-size: 0.9em; text-shadow: 1px 1px 2px black; }
        .hand { display: flex; flex-wrap: wrap; gap: 2px; justify-content: center; min-height: 50px; }
        .player-west .hand, .player-east .hand { flex-direction: column; gap: 1px; }
        .card { border: 1px solid black; border-radius: 5px; padding: 5px; min-width: 40px; min-height: 60px; background-color: white; display: inline-flex; flex-direction: column; justify-content: space-between; align-items: center; font-size: 1em; cursor: default; box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3); position: relative; user-select: none; transition: transform 0.2s ease, box-shadow 0.2s ease, border 0.2s ease; }
        .card.playable { cursor: pointer; border: 2px solid yellow; box-shadow: 0 0 10px yellow; }
        .card.playable:hover { transform: translateY(-10px); }
        .card span { display: block; text-align: center; font-weight: bold; }
        .card .rank { font-size: 1.2em; }
        .card .suit { font-size: 1.5em; }
        .card.spades .suit, .card.clubs .suit { color: black; }
        .card.hearts .suit, .card.diamonds .suit { color: red; }
        .card.hidden { background-color: #b0b0b0; background-image: repeating-linear-gradient(45deg, #a0a0a0, #a0a0a0 5px, #b0b0b0 5px, #b0b0b0 10px ); color: transparent; box-shadow: none; border: 1px solid #777; }
        .player-west .card.hidden, .player-east .card.hidden { min-width: 20px; min-height: 60px; }
        .player-north .card.hidden { min-width: 40px; min-height: 30px; }
        .trick-area { position: absolute; top: 20%; left: 15%; width: 70%; height: 60%; pointer-events: none; z-index: 10; }
        .trick-card-slot { position: absolute; transform: translate(-50%, -50%); }
        .trick-card-slot.player-S { top: 75%; left: 50%; }
        .trick-card-slot.player-W { top: 50%; left: 25%; }
        .trick-card-slot.player-N { top: 25%; left: 50%; }
        .trick-card-slot.player-E { top: 50%; left: 75%; }
        .controls-area { position: absolute; bottom: calc(10px + 70px + 10px); left: 50%; transform: translateX(-50%); background: rgba(255, 255, 255, 0.8); padding: 10px; border-radius: 5px; text-align: center; z-index: 60; display: none; }
        .controls-area.visible { display: block; }
        .controls-area button { padding: 8px 15px; margin: 5px; font-size: 1em; cursor: pointer; border: none; border-radius: 5px; background-color: #4CAF50; color: white; transition: background-color 0.2s ease; }
        .controls-area button:hover:not(:disabled) { background-color: #45a049; }
        .controls-area button:disabled { background-color: #cccccc; cursor: not-allowed; }
        .controls-area button.pass { background-color: #f44336; }
        .controls-area button.pass:hover:not(:disabled) { background-color: #da190b; }
        .controls-area button.bid { background-color: #2196F3; }
        .controls-area button.bid:hover:not(:disabled) { background-color: #0b7dda; }
        .announcements, .messages, .score-board { margin-top: 10px; background: rgba(255, 255, 255, 0.8); padding: 10px; border-radius: 5px; text-align: center; width: 90%; max-width: 600px; }
        .announcements { min-height: 50px; text-align: left; }
        .announcements p { text-align: center; margin-bottom: 5px; font-weight: bold; }
        .declared-announcement-item { margin: 2px 0; padding: 3px; border-bottom: 1px dotted #ccc; font-size: 0.9em; }
        .declared-announcement-item:last-child { border-bottom: none; }
        .messages { min-height: 40px; font-weight: bold; color: #333; }
        .score-board { font-size: 1.1em; }
        .modal { display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); padding-top: 60px; }
        .modal-content { background-color: #fefefe; margin: 5% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 500px; border-radius: 8px; text-align: center; }
        .modal-content h3 { margin-top: 0; }
        .modal-announcement-list label { display: block; margin: 8px 0; cursor: pointer; padding: 5px; border: 1px solid #eee; border-radius: 4px; }
        .modal-announcement-list label:hover { background-color: #f0f0f0; }
        .modal-announcement-list input[type="checkbox"] { margin-right: 10px; }
        .modal-close-btn { margin-top: 15px; padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 1em; }
        .modal-close-btn:hover { background-color: #45a049; }

        .connection-setup { border: 1px solid #ccc; padding: 15px; margin: 20px auto; width: 90%; max-width: 600px; background-color: #f9f9f9; border-radius: 8px; text-align: center; }
        .connection-setup h2 { margin-top: 0; }
        .connection-setup input[type="text"],
        .connection-setup button { padding: 8px; margin: 5px; border-radius: 4px; border: 1px solid #ddd; }
        .connection-setup button { background-color: #5cb85c; color: white; cursor: pointer; }
        .connection-setup button:hover { background-color: #4cae4c; }
        #host-panel, #guest-panel { margin-top: 15px; padding: 10px; border: 1px dashed #aaa; }
        #guest-list { list-style: none; padding-left: 0; text-align: left;}
        #guest-list li { padding: 3px; border-bottom: 1px solid #eee; }
        #guest-list li:last-child { border-bottom: none; }

        @media (max-width: 600px) { body { padding: 5px; } .game-container { padding: 10px 5px; aspect-ratio: 3 / 4; } .card { min-width: 30px; min-height: 45px; font-size: 0.8em; padding: 3px; } .card .rank { font-size: 1em; } .card .suit { font-size: 1.2em; } .player-area { min-width: 60px; min-height: 50px; } .hand { min-height: 40px; } .player-west .card.hidden, .player-east .card.hidden { min-width: 15px; min-height: 45px; } .player-north .card.hidden { min-width: 30px; min-height: 20px; } .trick-card-slot.player-S { top: 78%; } .trick-card-slot.player-W { left: 20%; } .trick-card-slot.player-N { top: 22%; } .trick-card-slot.player-E { left: 80%; } .persistent-trump { font-size: 0.8em; padding: 3px 6px; top: 5px; right: 5px; } .controls-area { width: 80%; bottom: calc(10px + 50px + 5px); } .controls-area button { padding: 6px 10px; font-size: 0.9em; margin: 3px; } .messages, .score-board, .announcements { font-size: 0.9em; padding: 5px; } }
        @media (max-width: 400px) { .card { min-width: 25px; min-height: 40px; font-size: 0.7em; } .player-west .card.hidden, .player-east .card.hidden { min-width: 10px; min-height: 40px; } .player-north .card.hidden { min-width: 25px; min-height: 15px; } .trick-card-slot.player-S { top: 80%; } .trick-card-slot.player-N { top: 20%; } }
    </style>
</head>
<body>

    <h1>Белот Русе P2P (Демо v7.1)</h1>

    <div class="connection-setup">
        <h2>Мултиплейър за 4 Играча</h2>
        <div id="role-selection">
            <input type="text" id="player-name-input" placeholder="Вашето име" value="Играч">
            <button id="become-host-btn">Аз съм Хост</button>
            <button id="become-guest-btn">Аз съм Гост</button>
        </div>

        <div id="host-panel" style="display:none;">
            <h3>Вие сте Хост</h3>
            <p>Споделете този Код на Стаята (Вашият Peer ID) с другите 3 играча:</p>
            <p>
                <strong id="host-peer-id-display" style="font-size: 1.2em; background: #eee; padding: 5px;">Зареждане...</strong>
                <button id="copy-host-id-btn" style="margin-left: 10px;">Копирай</button>
            </p>
            <p>Свързани гости: <span id="connected-guests-count">0</span>/3</p>
            <h4>Списък на гостите:</h4>
            <ul id="guest-list"></ul>
            <button id="mp-start-game-btn" disabled>Старт на Играта (Нужни са 3 госта)</button>
        </div>

        <div id="guest-panel" style="display:none;">
            <h3>Вие сте Гост</h3>
            <p>Въведете Кода на Стаята (Peer ID на Хоста):</p>
            <input type="text" id="host-id-input" placeholder="Код от Хоста">
            <button id="connect-to-host-btn">Свържи се с Хоста</button>
        </div>
        <div id="mp-connection-status" style="margin-top:10px; font-weight: bold;">Статус: Изберете роля.</div>
    </div>


    <div class="game-container" style="display:none;">
         <div id="persistent-trump-info" class="persistent-trump">Коз: N/A</div>
         <div id="player-area-N" class="player-area player-north"><div class="player-name">Север</div><div class="hand" id="hand-N"></div></div>
         <div id="player-area-E" class="player-area player-east"><div class="player-name">Изток</div><div class="hand" id="hand-E"></div></div>
         <div id="player-area-S" class="player-area player-south"><div class="hand" id="hand-S"></div><div class="player-name">Юг (Вие)</div></div>
         <div id="player-area-W" class="player-area player-west"><div class="player-name">Запад</div><div class="hand" id="hand-W"></div></div>
         <div class="trick-area" id="trick-area"> <div id="trick-slot-S" class="trick-card-slot player-S"></div> <div id="trick-slot-W" class="trick-card-slot player-W"></div> <div id="trick-slot-N" class="trick-card-slot player-N"></div> <div id="trick-slot-E" class="trick-card-slot player-E"></div> </div>
         <div class="controls-area" id="controls-area"> <p>Вашият ход:</p> <div id="controls-buttons"></div> </div>
    </div>

    <div class="announcements" id="declared-announcements-display" style="display:none;"> <p>Обявени Анонси:</p> <div id="declared-announcements-list">Няма обявени анонси в този рунд.</div> </div>
    <div class="messages" id="messages">Изберете роля, за да започнете.</div>
    <div class="score-board" id="score-board" style="display:none;">Резултат: Ние: 0 - Те: 0</div>
    <!-- <div style="margin-top: 10px;"> <button id="start-game-btn">Старт Локална Игра</button> </div> -->
    <div id="announcementModal" class="modal"> <div class="modal-content"> <h3>Обявете вашите анонси (първа ръка):</h3> <div id="modal-announcement-list" class="modal-announcement-list"></div> <button id="modal-confirm-btn" class="modal-close-btn">Потвърди и играй</button> </div> </div>

    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script>
        // --- Константи и Глобални Променливи ---
        const SUITS = { SPADES: '♠', HEARTS: '♥', DIAMONDS: '♦', CLUBS: '♣' };
        const SUIT_KEYS = Object.keys(SUITS);
        const RANKS = ['7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const PLAYERS = ['S', 'W', 'N', 'E'];
        const POINTS_NO_TRUMP = { '7': 0, '8': 0, '9': 0, '10': 10, 'J': 2, 'Q': 3, 'K': 4, 'A': 11 };
        const POINTS_TRUMP    = { '7': 0, '8': 0, '9': 14, '10': 10, 'J': 20, 'Q': 3, 'K': 4, 'A': 11 };
        const RANK_ORDER_FOR_SEQ = ['7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const ANNOUNCEMENTS_DEF = {
            'BELOT':   { value: 10, points: 20, name: "Белот" },
            'TERCA':   { value: 20, points: 20, name: "Терца", rankValue: -1 },
            'QUARTA':  { value: 30, points: 50, name: "Кварта", rankValue: -1 },
            'QUINTA':  { value: 40, points: 100, name: "Квинта", rankValue: -1 },
            'SQ_7':    { value: 15, points: 0, name: "4x7", rankValue: RANK_ORDER_FOR_SEQ.indexOf('7') },
            'SQ_8':    { value: 15, points: 0, name: "4x8", rankValue: RANK_ORDER_FOR_SEQ.indexOf('8') },
            'SQ_9':    { value: 15, points: 0, name: "4x9", rankValue: RANK_ORDER_FOR_SEQ.indexOf('9') },
            'SQ_10':   { value: 50, points: 100, name: "4x10", rankValue: RANK_ORDER_FOR_SEQ.indexOf('10') },
            'SQ_Q':    { value: 50, points: 100, name: "4xQ", rankValue: RANK_ORDER_FOR_SEQ.indexOf('Q') },
            'SQ_K':    { value: 50, points: 100, name: "4xK", rankValue: RANK_ORDER_FOR_SEQ.indexOf('K') },
            'SQ_A':    { value: 60, points: 150, name: "4xA", rankValue: RANK_ORDER_FOR_SEQ.indexOf('A') },
            'SQ_J':    { value: 70, points: 200, name: "4xJ", rankValue: RANK_ORDER_FOR_SEQ.indexOf('J') },
            'SQ_10_NT':{ value: 75, points: 200, name: "4x10 (Без Коз)", rankValue: RANK_ORDER_FOR_SEQ.indexOf('10') },
            'SQ_A_NT': { value: 80, points: 400, name: "4xA (Без Коз)", rankValue: RANK_ORDER_FOR_SEQ.indexOf('A') },
        };
        const BIDS = ['PASS', 'CLUBS', 'DIAMONDS', 'HEARTS', 'SPADES', 'NO_TRUMP', 'ALL_TRUMP'];
        const BID_NAMES = {
            'PASS': 'Пас', 'CLUBS': '♣ Спатия', 'DIAMONDS': '♦ Каро', 'HEARTS': '♥ Купа',
            'SPADES': '♠ Пика', 'NO_TRUMP': 'Без Коз', 'ALL_TRUMP': 'Всичко Коз'
        };

        let deck = [];
        let hands = { 'S': [], 'W': [], 'N': [], 'E': [] };
        let currentDealer = 'S';
        let currentPlayer = '';
        let gameState = 'INIT';
        let currentBid = { player: null, bid: 'PASS', level: -1 };
        let biddingHistory = [];
        let trumpSuit = null;
        let currentTrick = [];
        let trickHistory = [];
        let teamScores = { 'NS': 0, 'EW': 0 };
        let roundScores = { 'NS': { points: 0, announcements: 0 }, 'EW': { points: 0, announcements: 0 } };
        let potentialAnnouncements = { 'S': [], 'W': [], 'N': [], 'E': [] };
        let declaredAnnouncements = { 'S': [], 'W': [], 'N': [], 'E': [] };
        let playerDeclaredFlags = { 'S': false, 'W': false, 'N': false, 'E': false };
        let belotStatus = { S:{hasKQ:!1,declared:!1},W:{hasKQ:!1,declared:!1},N:{hasKQ:!1,declared:!1},E:{hasKQ:!1,declared:!1} };
        let myPosition = null;

        // --- Мултиплейър Променливи ---
        let peer;
        let myPeerId = null;
        let isHost = false;
        let gameMode = 'INIT_MP';
        let guestConnections = {};
        let hostConnection = null;
        let connectedGuestsCount = 0;
        let playerNames = {};
        let playerPeerIds = {};

        // --- DOM Елементи ---
        let persistentTrumpInfoEl, playerAreaEls, playerHands, trickAreaEl, trickCardSlots,
            controlsAreaEl, controlsButtonsEl, declaredAnnouncementsDisplayEl,
            declaredAnnouncementsListEl, messagesEl, scoreBoardEl,
            announcementModal, modalAnnouncementsList, modalConfirmBtn,
            roleSelectionEl, playerNameInputEl, becomeHostBtnEl, becomeGuestBtnEl,
            hostPanelEl, hostPeerIdDisplayEl, copyHostIdBtnEl, connectedGuestsCountEl, guestListEl, mpStartGameBtnEl,
            guestPanelEl, hostIdInputEl, connectToHostBtnEl,
            mpConnectionStatusEl, gameContainerEl;

        // --- Помощни UI Функции ---
        function setMessage(msg) { console.log("MSG:", msg); if(messagesEl) messagesEl.textContent = msg; else console.warn("setMessage called before messagesEl assigned!"); }
        function updateScoreBoard() { if(scoreBoardEl) scoreBoardEl.textContent = `Резултат: Ние (С/Ю): ${teamScores['NS']} - Те (И/З): ${teamScores['EW']}`; else console.warn("updateScoreBoard called before scoreBoardEl assigned!"); }
        function renderCard(card, isHidden = false, isPlayableCard = false) { if (!card && isHidden) return `<div class="card hidden"></div>`; if (!card || !card.suit || !card.rank || !card.id) { console.error(`renderCard Error: Invalid card!`, card); return '<div class="card error">?</div>'; } const suitKey = Object.keys(SUITS).find(key => SUITS[key] === card.suit); if (!suitKey) { console.error(`renderCard Error: Invalid suit "${card.suit}"`); return '<div class="card error">?</div>'; } const suitClass = suitKey.toLowerCase(); const playableClass = isPlayableCard ? ' playable' : ''; return `<div class="card ${suitClass}${playableClass}" data-card-id="${card.id}"><span class="rank">${card.rank}</span><span class="suit">${card.suit}</span></div>`; }
                function renderHand(playerPos) {
            const handEl = playerHands[playerPos];
            if (!handEl) {
                console.error(`renderHand Error: El not found for ${playerPos}`);
                return;
            }
            const cards = hands[playerPos]; // Вземаме картите за дадената ПОЗИЦИЯ
            // console.log(`renderHand for ${playerPos}. Card count: ${cards?.length}. MyPos: ${myPosition}. CurrentPlayer: ${currentPlayer}`);
            handEl.innerHTML = ''; // Изчистваме преди рендиране

            if (!cards) {
                console.warn(`renderHand: No cards array found for player at pos ${playerPos}.`);
                return;
            }
            if (cards.length === 0 && gameState !== 'INIT' && gameState !== 'LOBBY' && gameState !== 'DEALING') { // Добавено gameState !== 'DEALING'
                // console.log(`renderHand: Player ${playerPos} has 0 cards (and not init/lobby/dealing). Rendering empty.`);
                return;
            }

            const isMyHand = playerPos === myPosition;

            if (!isMyHand && gameState !== 'GAME_OVER') {
                // Рендираме скрити карти за други играчи
                let hiddenCardsHtml = '';
                for (let i = 0; i < cards.length; i++) { // Използваме cards.length, за да знаем колко скрити да покажем
                    hiddenCardsHtml += renderCard(null, true);
                }
                handEl.innerHTML = hiddenCardsHtml;
            } else {
                // Рендираме видими карти за моя играч или в края на играта
                const canPlayNow = gameState === 'PLAYING' && currentPlayer === playerPos && isMyHand;
                // console.log(`renderHand for ${playerPos}. MyPos: ${myPosition}. CurrentPlayer: ${currentPlayer}. gameState: ${gameState}. Calculated canPlayNow: ${canPlayNow}`);

                let cardsHtml = ''; // <--- ВАЖНО: ДЕФИНИЦИЯТА ТРЯБВА ДА Е ТУК
                cards.forEach((card, index) => {
                    try {
                         if (!card || !card.id) { // Проверка за валидност на картата
                             console.error(`renderHand Error: Invalid card data at index ${index} for player ${playerPos}:`, card);
                             cardsHtml += '<div class="card error">!</div>'; // Добавяме карта-грешка
                             return; // Пропусни тази карта в forEach
                         }
                         let playable = false;
                         if (canPlayNow && gameState === 'PLAYING' && currentTrick !== undefined) {
                             playable = isPlayable(playerPos, card);
                         }
                         cardsHtml += renderCard(card, false, playable);
                    } catch (e) {
                         console.error(`Error rendering card ${card?.id} for player ${playerPos}:`, e);
                         cardsHtml += '<div class="card error">E</div>'; // Друг вид грешка
                    }
                });
                handEl.innerHTML = cardsHtml; // Поставяме целия HTML наведнъж

                // Добавяне на event listeners след като HTML е генериран
                 if (canPlayNow) {
                     handEl.querySelectorAll('.card.playable').forEach(cardEl => {
                         // Премахваме стари слушатели, като клонираме и заменим елемента
                         const oldEl = cardEl;
                         const newEl = oldEl.cloneNode(true);
                         oldEl.parentNode.replaceChild(newEl, oldEl);
                         newEl.addEventListener('click', () => {
                             handlePlayCard(myPosition, newEl.dataset.cardId); // Изпращаме НАШАТА позиция
                         });
                     });
                 }
             }
        }
        function renderAllHands() { // ДЕФИНИЦИЯТА Е ТУК
            console.log("Rendering all hands...");
            PLAYERS.forEach(playerPos => renderHand(playerPos));
        }
        function renderTrickArea() { clearTrickArea(); currentTrick.forEach(play => { const slot = trickCardSlots[play.player]; if (slot) { try { const cardElString = renderCard(play.card); const tempDiv = document.createElement('div'); tempDiv.innerHTML = cardElString.trim(); const cardEl = tempDiv.firstChild; if(cardEl) slot.appendChild(cardEl); else console.error("renderTrickArea: Failed to create card el"); } catch (e) { console.error(`Error rendering trick card for ${play.player}:`, e); } } else { console.error("renderTrickArea Error: No slot for:", play.player); } }); }
        function clearTrickArea() { PLAYERS.forEach(p => { if(trickCardSlots && trickCardSlots[p]) trickCardSlots[p].innerHTML=''; }); }
        function hideBiddingControls() { if(controlsAreaEl) controlsAreaEl.classList.remove('visible'); if(controlsButtonsEl) controlsButtonsEl.innerHTML = ''; }
        function updateCurrentPlayerHighlight() { PLAYERS.forEach(p => playerAreaEls[p]?.classList.toggle('current-player', p===currentPlayer&&(gameState==='BIDDING'||gameState==='PLAYING'))); }
        function clearCurrentPlayerHighlight() { PLAYERS.forEach(p => playerAreaEls[p]?.classList.remove('current-player')); }
        function updateBiddingControls() { hideBiddingControls(); if (gameState !== 'BIDDING') return; if (currentPlayer === myPosition) { controlsAreaEl.classList.add('visible'); controlsButtonsEl.innerHTML = ''; const currentLevel = BIDS.indexOf(currentBid.bid); const passBtn = document.createElement('button'); passBtn.textContent = BID_NAMES['PASS']; passBtn.classList.add('pass'); passBtn.onclick = () => handleBid(myPosition, 'PASS'); controlsButtonsEl.appendChild(passBtn); BIDS.slice(1).forEach((bid) => { const btn = document.createElement('button'); btn.textContent = BID_NAMES[bid]; btn.classList.add('bid'); const bidLevel = BIDS.indexOf(bid); btn.disabled = bidLevel <= currentLevel; btn.onclick = () => handleBid(myPosition, bid); controlsButtonsEl.appendChild(btn); }); } else { setMessage(`Наддаване: Ред на ${getPlayerName(playerNames[currentPlayer] || currentPlayer)}`); } }
        function updatePersistentTrumpInfo() { let htmlContent = ""; if (!persistentTrumpInfoEl) return; if (!trumpSuit || trumpSuit === 'PASS' || gameState === 'BIDDING' || gameState === 'DEALING' || gameState === 'DEALING_FINAL') { htmlContent = currentBid.bid === 'PASS' ? "Наддаване..." : `Последно: ${getPlayerName(playerNames[currentBid.player] || currentBid.player)} - ${BID_NAMES[currentBid.bid]}`; } else if (trumpSuit === 'NO_TRUMP') htmlContent = `<strong>Без Коз</strong><br/>(${getPlayerName(playerNames[currentBid.player] || currentBid.player)})`; else if (trumpSuit === 'ALL_TRUMP') htmlContent = `<strong>Всичко Коз</strong><br/>(${getPlayerName(playerNames[currentBid.player] || currentBid.player)})`; else { const sSym = SUITS[trumpSuit]; const sClass = trumpSuit.toLowerCase(); htmlContent = `<span class="suit ${sClass}">${sSym}</span> (${BID_NAMES[trumpSuit]})<br/>(${getPlayerName(playerNames[currentBid.player] || currentBid.player)})`; } persistentTrumpInfoEl.innerHTML = htmlContent; }
        function updatePlayableCards() { if(myPosition && PLAYERS.includes(myPosition)) renderHand(myPosition); }
        function cardToString(card) { return card ? `${card.rank}${card.suit}` : ''; }
        function updateDeclaredAnnouncementsDisplay() { if (!declaredAnnouncementsListEl) return; declaredAnnouncementsListEl.innerHTML = ''; let hasAnyDeclared = false; PLAYERS.forEach(playerPos => { if(declaredAnnouncements[playerPos] && declaredAnnouncements[playerPos].length > 0) { declaredAnnouncements[playerPos].forEach(ann => { hasAnyDeclared = true; const item = document.createElement('div'); item.classList.add('declared-announcement-item'); let text = `<strong>${getPlayerName(playerNames[playerPos] || playerPos)}:</strong> ${ANNOUNCEMENTS_DEF[ann.type]?.name || ann.type}`; if (ann.type.startsWith('SQ')) text += ` (${ann.rank})`; else if (ann.type !== 'BELOT') text += ` до ${ann.rank}${ann.suit}`; if (ANNOUNCEMENTS_DEF[ann.type]?.points === 0 && ann.type !== 'BELOT') text += " (0т)"; else if (ann.type !== 'BELOT') text += ` (${ANNOUNCEMENTS_DEF[ann.type]?.points || 0}т.)`; else text += ` (${ANNOUNCEMENTS_DEF[ann.type]?.points || 0}т.)`; item.innerHTML = text; declaredAnnouncementsListEl.appendChild(item); }); } }); if (!hasAnyDeclared) { declaredAnnouncementsListEl.innerHTML = 'Няма обявени анонси в този рунд.'; } }
        function showAnnouncementModal(announcements) { if (!announcementModal || !modalAnnouncementsList || !modalConfirmBtn) return; console.log("Showing announcement modal for human"); modalAnnouncementsList.innerHTML = ''; announcements.forEach(ann => { const label = document.createElement('label'); const cb = document.createElement('input'); cb.type = 'checkbox'; cb.value = ann.id; cb.id = `ann-check-${ann.id}`; let txt = ANNOUNCEMENTS_DEF[ann.type]?.name || ann.type; if (ann.type.startsWith('SQ')) txt += ` (${ann.rank})`; else txt += ` до ${ann.rank}${ann.suit}`; if (ANNOUNCEMENTS_DEF[ann.type]?.points === 0) txt += " (0т)"; label.appendChild(cb); label.appendChild(document.createTextNode(` ${txt}`)); modalAnnouncementsList.appendChild(label); }); modalConfirmBtn.onclick = confirmHumanAnnouncements; announcementModal.style.display = 'block'; }
        function hideAnnouncementModal() { if(announcementModal) announcementModal.style.display = 'none'; }

        // --- Логика на Играта ---
        function createDeck() { deck = []; for (const sK in SUITS) { const s = SUITS[sK]; for (const r of RANKS) deck.push({ suit: s, rank: r, id: `${r}${s}` }); } }
        function shuffleDeck() { for (let i = deck.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [deck[i], deck[j]] = [deck[j], deck[i]]; } }
        function cutDeck() { if(deck.length<10)return; const mC=Math.floor(deck.length*.25),xC=Math.floor(deck.length*.75); const cP=Math.floor(Math.random()*(xC-mC+1))+mC; console.log(`Deck cut at ${cP}`); deck=deck.slice(cP).concat(deck.slice(0,cP)); }
        function getNextPlayer(p) { if (!p||PLAYERS.indexOf(p)===-1){console.error(`Invalid player "${p}"!`);return PLAYERS[0];} const i=PLAYERS.indexOf(p); return PLAYERS[(i+1)%4]; }
        function getPlayerOrderStartingFrom(sP) { if (!sP||PLAYERS.indexOf(sP)===-1){console.error(`Invalid startPlayer "${sP}"!`);return [...PLAYERS];} const i=PLAYERS.indexOf(sP); return [...PLAYERS.slice(i),...PLAYERS.slice(0,i)]; }
        function dealInitialCards() { console.log("dealInitialCards called. Dealer:", currentDealer, "GameMode:", gameMode); setMessage(`Раздава ${getPlayerName(playerNames[currentDealer] || currentDealer)}...`); gameState='DEALING'; hands={S:[],W:[],N:[],E:[]}; trickHistory=[]; currentTrick=[]; potentialAnnouncements={S:[],W:[],N:[],E:[]}; declaredAnnouncements={S:[],W:[],N:[],E:[]}; playerDeclaredFlags={S:!1,W:!1,N:!1,E:!1}; belotStatus={S:{hasKQ:!1,declared:!1},W:{hasKQ:!1,declared:!1},N:{hasKQ:!1,declared:!1},E:{hasKQ:!1,declared:!1}}; roundScores={NS:{points:0,announcements:0},EW:{points:0,announcements:0}}; trumpSuit=null; currentBid={player:null,bid:'PASS',level:-1}; biddingHistory=[]; clearTrickArea(); updatePersistentTrumpInfo(); hideBiddingControls(); if(declaredAnnouncementsListEl) declaredAnnouncementsListEl.innerHTML='Няма обявени анонси в този рунд.'; if (isHost || gameMode === 'LOCAL') { const nextP=getNextPlayer(currentDealer); let order=getPlayerOrderStartingFrom(nextP); if (!order||typeof order[Symbol.iterator]!=='function'){console.error("FATAL: playerOrder not iterable!", order); setMessage("Крит. грешка!"); return;} for(let i=0;i<3;i++){for(const p of order){if(deck.length>0){const c=deck.pop();if(c)hands[p].push(c);else console.warn("Popped undefined!");}else{console.warn("Deck empty (3)!");break;}}} for(let i=0;i<2;i++){for(const p of order){if(deck.length>0){const c=deck.pop();if(c)hands[p].push(c);else console.warn("Popped undefined!");}else{console.warn("Deck empty (2)!");break;}}} sortHands(); if (gameMode === 'MULTIPLAYER_HOST') { const handsData = {}; PLAYERS.forEach(pos => handsData[pos] = hands[pos]); broadcastToAll({ type: "DEAL_CARDS_PHASE1", hands: handsData, dealer: currentDealer }); } else { renderAllHands(); gameState='BIDDING'; startBidding(); } } }
        // --- Коригирана dealFinalCards (v7.3) ---
        function dealFinalCards() {
            console.log("Dealing final cards... GameMode:", gameMode, "IsHost:", isHost);
            if (isHost || gameMode === 'LOCAL') {
                setMessage('Финално раздаване на карти...');
                gameState = 'DEALING_FINAL'; // Все още сме във фаза раздаване
                let order = getPlayerOrderStartingFrom(getNextPlayer(currentDealer));
                for (let i = 0; i < 3; i++) { for (const p of order) { if (deck.length > 0) { const c = deck.pop(); if (c) hands[p].push(c); } else { console.warn("Deck empty final!"); break; } } }
                sortHands();
                detectAllAnnouncements();

                const handsData = {};
                PLAYERS.forEach(pos => handsData[pos] = hands[pos]);
                const firstPlayerToPlay = getNextPlayer(currentDealer); // Кой започва играта на карти

                if (gameMode === 'MULTIPLAYER_HOST') {
                    broadcastToAll({
                        type: "START_PLAYING_PHASE", // Ново съобщение
                        hands: handsData,
                        potentialAnnouncements: potentialAnnouncements,
                        currentPlayer: firstPlayerToPlay, // Изпращаме кой е на ход
                        trumpSuit: trumpSuit // Изпращаме и текущия коз
                    });
                } else { // LOCAL
                    renderAllHands(); // Трябва да се извика, за да се видят всички карти преди игра
                    gameState = 'PLAYING';
                    currentPlayer = firstPlayerToPlay;
                    updatePersistentTrumpInfo(); // Уверяваме се, че козът е показан
                    startPlayingPhase(); // Локалната игра стартира веднага
                }
            }
        }
        function sortHands() { const sO=[SUITS.CLUBS,SUITS.DIAMONDS,SUITS.HEARTS,SUITS.SPADES]; for(const p of PLAYERS){if(!hands[p])continue; hands[p].sort((a,b)=>{if(!a||!b)return 0; const sc=sO.indexOf(a.suit)-sO.indexOf(b.suit); if(sc!==0)return sc; const rvA=getRankValue(a,!1),rvB=getRankValue(b,!1); return rvA-rvB; });} }
        function startBidding() { currentPlayer=getNextPlayer(currentDealer); console.log("Bidding starts. Player:",currentPlayer,"(My pos:",myPosition,")"); setMessage(`Наддаване: Ред на ${getPlayerName(playerNames[currentPlayer]||currentPlayer)}`); if(persistentTrumpInfoEl) persistentTrumpInfoEl.textContent="Наддаване..."; biddingHistory=[]; updateCurrentPlayerHighlight(); updateBiddingControls();}
        // --- Корекция в handleBid (v7.3) ---
        function handleBid(playerPos, bid) {
            // Тази функция се извиква от:
            // 1. Локален клик, ако gameMode === 'LOCAL'
            // 2. Локален клик, ако isHost && playerPos === myPosition
            // 3. От handleNetworkMessage, ако isHost и е получен PLAYER_BID от гост
            console.log(`handleBid: Pos=${playerPos}, Bid=${bid}, CurrentPlayer=${currentPlayer}, MyPos=${myPosition}, IsHost=${isHost}`);

            if (playerPos !== currentPlayer || gameState !== 'BIDDING') {
                console.warn(`handleBid: Invalid bid by ${playerPos}. Current: ${currentPlayer}, State: ${gameState}`);
                return;
            }

            // Ако е гост, той вече е изпратил PLAYER_BID и чака.
            // Тази функция при госта се вика само при локална игра (която сме премахнали за момента)
            // или ако има грешка в логиката.
            if (gameMode.startsWith("MULTIPLAYER") && playerPos === myPosition && !isHost) {
                sendToHost({ type: "PLAYER_BID", bid: bid }); // playerPos се подразбира, че е myPosition
                hideBiddingControls();
                setMessage("Изпратено наддаване. Чакане...");
                return;
            }

            // Оттук нататък кодът се изпълнява само от ХОСТА (за себе си или за гост) или в ЛОКАЛНА игра.
            console.log(`${getPlayerName(playerNames[playerPos] || playerPos)} наддава: ${BID_NAMES[bid]}`);

            let validBidProcessed = false;
            const originalCurrentBidForLog = JSON.parse(JSON.stringify(currentBid)); // За логване

            if (bid === 'PASS') {
                biddingHistory.push({ player: playerPos, bid: bid });
                validBidProcessed = true;
            } else {
                const currentLevel = BIDS.indexOf(currentBid.bid);
                const newLevel = BIDS.indexOf(bid);
                if (newLevel > currentLevel) {
                    currentBid = { player: playerPos, bid: bid, level: newLevel };
                    biddingHistory.push({ player: playerPos, bid: bid });
                    validBidProcessed = true;
                } else {
                    setMessage("Невалидно наддаване (трябва да е по-високо).");
                    // Ако хостът играе за себе си или е локална игра, и е негов ред, показваме пак контролите
                    if ((isHost && playerPos === myPosition) || gameMode === 'LOCAL') {
                        updateBiddingControls();
                    }
                    return; // Невалиден бид, не продължаваме
                }
            }

            if (validBidProcessed) {
                if (isHost) {
                    // Хостът изпраща актуализация за направения бид
                    broadcastToAll({
                        type: "BID_UPDATE",
                        biddingPlayer: playerPos,
                        bidMade: bid,
                        currentHighestBid: currentBid, // Изпращаме новото currentBid
                        biddingHistory: biddingHistory
                    });
                } else if (gameMode === 'LOCAL') {
                    // Локално обновяване на UI (ако е нужно, BID_UPDATE би го направил и за хоста)
                    if (bid !== 'PASS') updatePersistentTrumpInfo();
                     // renderAllHands(); // Не е нужно, само UI за наддаване
                }

                // Проверяваме дали наддаването е приключило
                if (checkBiddingEnd()) {
                    if (isHost) {
                        broadcastToAll({ type: "BIDDING_END", finalBid: currentBid });
                    }
                    finalizeBidding(); // И хостът, и локалната игра извикват това
                } else {
                    // Ако не е приключило, хостът/локалната игра определя следващия
                    moveToNextBidder();
                }
            }
        }
        // --- Корекция в moveToNextBidder (изпълнява се САМО от хоста или в локална игра) ---
        function moveToNextBidder() {
            currentPlayer = getNextPlayer(currentPlayer); // Хостът/локалната игра сменя реда
            console.log(`moveToNextBidder (Host/Local): New current player is ${currentPlayer}`);

            if (isHost) {
                broadcastToAll({ type: "SET_CURRENT_PLAYER_BID", nextPlayer: currentPlayer });
            } else if (gameMode === 'LOCAL') {
                // При локална игра, директно подготвяме хода
                setMessage(`Наддаване: Ред на ${getPlayerName(playerNames[currentPlayer] || currentPlayer)}`);
                updateCurrentPlayerHighlight();
                updateBiddingControls(); // Това ще покаже бутоните за правилния играч
            }
        }
        function checkBiddingEnd() { if(biddingHistory.length<4)return!1; const l4=biddingHistory.slice(-4); if(l4.every(b=>b.bid==='PASS')){if(biddingHistory.length===4||(biddingHistory[biddingHistory.length-5]?.bid==='PASS'))return!0;} if(currentBid.bid!=='PASS'&&biddingHistory.length>=3){return biddingHistory.slice(-3).every(b=>b.bid==='PASS');} return!1;}
        function finalizeBidding() {hideBiddingControls();clearCurrentPlayerHighlight();if(currentBid.bid==='PASS'){setMessage("Всички пасуваха! Прераздаване...");gameState='INIT';if(isHost||gameMode==='LOCAL')setTimeout(startGame,2500);}else{trumpSuit=currentBid.bid;setMessage(`${getPlayerName(playerNames[currentBid.player]||currentBid.player)} спечели с ${BID_NAMES[trumpSuit]}! Финално раздаване...`);updatePersistentTrumpInfo();if(isHost||gameMode==='LOCAL')setTimeout(dealFinalCards,1500);}}
        function detectAllAnnouncements() { potentialAnnouncements={S:[],W:[],N:[],E:[]}; belotStatus={S:{hasKQ:!1,declared:!1},W:{hasKQ:!1,declared:!1},N:{hasKQ:!1,declared:!1},E:{hasKQ:!1,declared:!1}}; PLAYERS.forEach(p=>{const h=hands[p]; if(!h) return; const seq=findSequences(h); const kar=findKares(h,trumpSuit); let pot= [...seq,...kar]; if(trumpSuit&&trumpSuit!=='NO_TRUMP'&&trumpSuit!=='PASS'){const bel=findBelot(h); if(bel){pot.push(bel);belotStatus[p].hasKQ=!0;}else{belotStatus[p].hasKQ=!1;}}else{belotStatus[p].hasKQ=!1;} potentialAnnouncements[p]=pot;}); console.log("Potential Anns:", potentialAnnouncements); }
        function findSequences(h) { let seqs=[]; const byS={}; SUIT_KEYS.forEach(k=>byS[SUITS[k]]=[]); h.forEach(c=>byS[c.suit].push(c)); for(const s of Object.values(SUITS)){const sC=byS[s]; if(sC.length<3)continue; sC.sort((a,b)=>RANK_ORDER_FOR_SEQ.indexOf(a.rank)-RANK_ORDER_FOR_SEQ.indexOf(b.rank)); let cur=sC[0]?[sC[0]]:[]; for(let i=1;i<sC.length;i++){if(!cur||cur.length===0){cur=[sC[i]];continue;}if(!sC[i])continue; const cRI=RANK_ORDER_FOR_SEQ.indexOf(sC[i].rank); const pRI=RANK_ORDER_FOR_SEQ.indexOf(cur[cur.length-1].rank); if(cRI===pRI+1){cur.push(sC[i]);}else{if(cur.length>=3)seqs.push(createAnnouncementObject(cur)); cur=[sC[i]];}} if(cur&&cur.length>=3)seqs.push(createAnnouncementObject(cur));} let filt=[]; seqs.sort((a,b)=>{if(!a||!b)return 0; return b.value-a.value;}); for(const s of seqs){if(!s)continue; let isSub=!1; for(const ex of filt){if(!ex)continue; if(s.suit===ex.suit&&s.cards.every(sC=>ex.cards.some(eC=>eC.id===sC.id))){isSub=!0;break;}} if(!isSub)filt.push(s);} return filt;}
        function createAnnouncementObject(sC) { if(!sC||sC.length<3)return null; const len=sC.length; const hC=sC[len-1]; if(!hC)return null; let t=''; if(len>=5)t='QUINTA'; else if(len===4)t='QUARTA'; else if(len===3)t='TERCA'; else return null; const d=ANNOUNCEMENTS_DEF[t]; const rV=RANK_ORDER_FOR_SEQ.indexOf(hC.rank); return {type:t,rank:hC.rank,suit:hC.suit,value:d.value,points:d.points,rankValue:rV,id:`${t}-${hC.rank}-${hC.suit}`,cards:sC};}
        function findBelot(h) { if(!trumpSuit||trumpSuit==='NO_TRUMP'||trumpSuit==='PASS')return null; const tS=SUITS[trumpSuit]; const hK=h.some(c=>c.suit===tS&&c.rank==='K'); const hQ=h.some(c=>c.suit===tS&&c.rank==='Q'); if(hK&&hQ){const d=ANNOUNCEMENTS_DEF['BELOT']; return {type:'BELOT',suit:tS,value:d.value,points:d.points,id:`BELOT-${tS}`,cards:h.filter(c=>c.suit===tS&&(c.rank==='K'||c.rank==='Q'))};} return null; }
        function findKares(h,cT) { let k=[]; const byR={}; RANKS.forEach(r=>byR[r]=[]); h.forEach(c=>byR[c.rank].push(c)); for(const r of RANKS){if(byR[r].length===4){let oT=`SQ_${r}`; let kT=oT; let kD=ANNOUNCEMENTS_DEF[kT]; if(cT==='NO_TRUMP'){if(r==='A'&&ANNOUNCEMENTS_DEF['SQ_A_NT']){kT='SQ_A_NT';kD=ANNOUNCEMENTS_DEF[kT];}else if(r==='10'&&ANNOUNCEMENTS_DEF['SQ_10_NT']){kT='SQ_10_NT';kD=ANNOUNCEMENTS_DEF[kT];}} if(kD){k.push({type:kT,rank:r,value:kD.value,points:kD.points,rankValue:kD.rankValue,id:`${kT}`,cards:byR[r]});}}} return k;}
        function compareAnnouncements(a1,a2){if(!a1)return-1;if(!a2)return 1;if(a1.value!==a2.value)return a1.value-a2.value;if(a1.rankValue!==a2.rankValue)return a1.rankValue-a2.rankValue;return 0;}
        function startPlayingPhase() { console.log(`preparePlayerTurn called for ${currentPlayer}. My position: ${myPosition}. Is it my turn? ${currentPlayer === myPosition}`);setMessage(`Игра: ${BID_NAMES[trumpSuit]||'Грешка'}. Ред на ${getPlayerName(playerNames[currentPlayer]||currentPlayer)}.`); clearTrickArea(); currentTrick=[]; updateCurrentPlayerHighlight(); preparePlayerTurn();}
        function preparePlayerTurn(){console.log(`preparePlayerTurn ${currentPlayer}. MyPos: ${myPosition}. Trick#: ${trickHistory.length}, Declared: ${playerDeclaredFlags[currentPlayer]}`);if (trickHistory.length === 0 && currentPlayer === myPosition && !playerDeclaredFlags[myPosition]) {
        handleFirstTurnAnnouncement(myPosition);
    } else {
        allowCardPlay(myPosition);
    }}
        function handleFirstTurnAnnouncement(playerPos){console.log(`Handling 1st turn ann for ${playerPos}. Trump: ${trumpSuit}`); let allowedAnns=[]; const isNTG=trumpSuit==='NO_TRUMP'; if(isNTG){allowedAnns=potentialAnnouncements[playerPos]?.filter(a=>a&&(a.type==='SQ_A_NT'||a.type==='SQ_10_NT'))||[];}else{allowedAnns=potentialAnnouncements[playerPos]?.filter(a=>a&&a.type!=='BELOT'&&(ANNOUNCEMENTS_DEF[a.type]?.points>0||['SQ_7','SQ_8','SQ_9'].includes(a.type)))||[];} if(playerPos===myPosition){if(allowedAnns.length>0){showAnnouncementModal(allowedAnns);}else{setMessage("Няма анонси. Играй."); playerDeclaredFlags[playerPos]=!0; allowCardPlay(playerPos);}}else{ playerDeclaredFlags[playerPos]=!0; allowCardPlay(playerPos);}}
        function confirmHumanAnnouncements(){console.log("Human confirmed anns"); let declaredByMe=[]; const cbs=modalAnnouncementsList.querySelectorAll('input[type="checkbox"]:checked'); cbs.forEach(cb=>{const ann=potentialAnnouncements[myPosition].find(a=>a.id===cb.value); if(ann)declaredByMe.push(ann);}); playerDeclaredFlags[myPosition]=!0; hideAnnouncementModal(); if(gameMode.startsWith("MULTIPLAYER")){sendToHostOrBroadcast({type:"PLAYER_ANNOUNCEMENTS",announcements:declaredByMe,playerPos:myPosition});}else{declaredAnnouncements[myPosition]=declaredByMe;updateDeclaredAnnouncementsDisplay();} setMessage("Изберете карта.");allowCardPlay(myPosition);}
        function allowCardPlay(playerPos){if(playerPos===myPosition){console.log(`Allowing card play for ME (${myPosition})`);updatePlayableCards();}else{console.log(`Not my turn (${currentPlayer}) or not my pos (${myPosition}) to play.`);}}
        function processPlayedCard(playerPos, cardId) { console.log(`HOST processPlayedCard for player: ${playerPos}, card: ${cardId}. Current player: ${currentPlayer}`); if (playerPos !== currentPlayer || gameState !== 'PLAYING') { console.warn("processPlayedCard: Not current player or not playing state."); return; } const cardToPlay = hands[playerPos]?.find(c => c.id === cardId); if (!cardToPlay) { console.error("processPlayedCard: Card not found!"); return; } hands[playerPos] = hands[playerPos].filter(c => c.id !== cardId); currentTrick.push({ player: playerPos, card: cardToPlay }); let belotInfo = null; if (trumpSuit && trumpSuit !== 'NO_TRUMP' && trumpSuit !== 'PASS' && belotStatus[playerPos].hasKQ && !belotStatus[playerPos].declared) { const trumpSuitSymbol = SUITS[trumpSuit]; if (cardToPlay.suit === trumpSuitSymbol && (cardToPlay.rank === 'K' || cardToPlay.rank === 'Q')) { const belotAnn = potentialAnnouncements[playerPos]?.find(a => a.type === 'BELOT'); if (belotAnn) { belotStatus[playerPos].declared = true; const belotMessage = `${getPlayerName(playerNames[playerPos] || playerPos)} обявява БЕЛОТ!`; if (!declaredAnnouncements[playerPos].some(a => a.type === 'BELOT')) { declaredAnnouncements[playerPos].push(belotAnn); } belotInfo = { playerPos: playerPos, message: belotMessage, announcements: declaredAnnouncements[playerPos] }; } } } if (isHost) { broadcastToAll({ type: "CARD_PLAYED", playerPos: playerPos, card: cardToPlay, currentTrick: currentTrick, belotInfo: belotInfo }); determineNextActionAfterPlay(); } else if (gameMode === 'LOCAL') { renderHand(playerPos); renderTrickArea(); if (belotInfo) { updateDeclaredAnnouncementsDisplay(); setMessage(belotInfo.message); } determineNextActionAfterPlay(); } }
        function handlePlayCard(playerPos_ShouldBeMyPosition, cardId) { console.log(`handlePlayCard CLICK by ME (${myPosition}), cardId: ${cardId}. CurrentPlayer: ${currentPlayer}`); if (myPosition !== currentPlayer || gameState !== 'PLAYING') { console.warn("handlePlayCard: Not my turn or not playing state."); return; } if (trickHistory.length === 0 && !playerDeclaredFlags[myPosition]) { setMessage("Моля, първо потвърдете анонсите си."); if (announcementModal && announcementModal.style.display === 'block') { return; } } const cardToPlay = hands[myPosition]?.find(c => c.id === cardId); if (!cardToPlay) { console.error("handlePlayCard: Card not found in my hand!"); return; } if (!isPlayable(myPosition, cardToPlay)) { setMessage("Невалиден ход!"); console.warn("handlePlayCard: Card is not playable."); return; } if (gameMode.startsWith("MULTIPLAYER")) { if (isHost) { console.log("Host initiating card play for self:", cardToPlay.id); processPlayedCard(myPosition, cardId); } else { console.log("Guest playing card, sending to host:", cardToPlay.id); sendToHost({ type: "PLAY_CARD", cardId: cardId, playerPos: myPosition }); hideBiddingControls(); setMessage("Изпратена карта. Чакане..."); } } else { console.log("Local game, playing card:", cardToPlay.id); processPlayedCard(myPosition, cardId); } }
        // --- КОРИГИРАНА determineNextActionAfterPlay (САМО за хост/локална игра) (v7.4) ---
        function determineNextActionAfterPlay() {
            console.log("HOST/LOCAL: determineNextActionAfterPlay. Trick length:", currentTrick.length);
            if (currentTrick.length === 4) {
                // Взятката е пълна, хостът определя победителя
                determineTrickWinner(); // Тази функция ще изпрати TRICK_RESULT
                                        // и ако не е последна взятка, determineTrickWinner (чрез setTimeout)
                                        // трябва да инициира следващия SET_CURRENT_PLAYER
            } else {
                // Взятката не е пълна, преминаваме към следващия играч
                const newCurrentPlayer = getNextPlayer(currentPlayer);
                if (isHost) {
                    // Хостът веднага актуализира своя currentPlayer И изпраща на всички
                    currentPlayer = newCurrentPlayer;
                    broadcastToAll({ type: "SET_CURRENT_PLAYER", nextPlayer: newCurrentPlayer });
                    // Хостът също извиква preparePlayerTurn за себе си, ако е негов ред
                    // Това ще стане, когато получи собственото си SET_CURRENT_PLAYER съобщение
                } else if (gameMode === 'LOCAL') {
                    currentPlayer = newCurrentPlayer;
                    setMessage(`Игра: Ред ${getPlayerName(playerNames[currentPlayer] || currentPlayer)}.`);
                    updateCurrentPlayerHighlight();
                    preparePlayerTurn();
                }
            }
        }
        // --- КОРИГИРАНА determineTrickWinner (v7.4 - изпълнява се САМО от хоста или в локална игра) ---
        function determineTrickWinner() {
            gameState = 'SCORING_TRICK'; // Поставяме състоянието
            clearCurrentPlayerHighlight(); // Изчистваме подсветката
            setMessage('Изчисляване на взятката...');

            let winningPlay = findCurrentTrickWinner(); // Вземаме целия обект {player, card}
            if (!winningPlay || !winningPlay.card) {
                console.error("CRITICAL: No trick winner or winning card found in determineTrickWinner!");
                // Опит за възстановяване или спиране на рунда - засега просто логваме
                // и може би преминаваме към следващ дилър, ако е възможно
                // За сега, нека продължим, но това е лоша ситуация
                if (currentTrick.length > 0) winningPlay = currentTrick[0]; // Вземи първата карта като fallback
                else return; // Не можем да направим нищо повече
            }

            const winnerOfTrick = winningPlay.player;
            let pointsForTrick = 0;
            currentTrick.forEach(play => {
                if (play && play.card) pointsForTrick += getCardPoints(play.card);
            });

            const isLastTrickOfRound = PLAYERS.every(p => hands[p]?.length === 0);

            if (isLastTrickOfRound) pointsForTrick += 10;

            const winningTeam = (winnerOfTrick === 'N' || winnerOfTrick === 'S') ? 'NS' : 'EW';
            roundScores[winningTeam].points += pointsForTrick;
            trickHistory.push({ winner: winnerOfTrick, trick: [...currentTrick], points: pointsForTrick }); // Запазваме копие на взятката

            // Важно: currentTrick се изчиства СЛЕД като се изпрати TRICK_RESULT или се обработи локално
            const trickToSend = [...currentTrick]; // Запазваме копие за изпращане

            if (isHost) {
                broadcastToAll({
                    type: "TRICK_RESULT",
                    winner: winnerOfTrick,
                    winningCard: winningPlay.card,
                    points: pointsForTrick,
                    isLastTrick: isLastTrickOfRound,
                    roundScores: JSON.parse(JSON.stringify(roundScores)), // Изпращаме копие
                    currentTrickForDisplay: trickToSend // Изпращаме копие на взятката за показване
                });
            } else if (gameMode === 'LOCAL') {
                setMessage(`${getPlayerName(playerNames[winnerOfTrick] || winnerOfTrick)} печели с ${cardToString(winningPlay.card)}. Точки: ${pointsForTrick}${isLastTrickOfRound ? ' (+10)' : ''}`);
                // За локална игра, setTimeout е тук
                setTimeout(() => {
                    clearTrickArea();
                    currentTrick = []; // Изчистваме за следващата взятка
                    if (isLastTrickOfRound) {
                        endRound();
                    } else {
                        currentPlayer = winnerOfTrick;
                        gameState = 'PLAYING';
                        startPlayingPhase(); // Това ще извика preparePlayerTurn
                    }
                }, 1800);
            }
        }
        function endRound() {
            gameState = 'END_ROUND';
            let initialMessage = 'Край на рунда. Изчисляване...';

            const isNoTrumpGame = trumpSuit === 'NO_TRUMP';
            const isAllTrumpGame = trumpSuit === 'ALL_TRUMP';
            const multiplier = isNoTrumpGame ? 2 : 1;

            // --- 1. Точкуване на Анонси ---
            let highestAnnNS = null; let highestAnnEW = null;
            let belotPointsNS = 0; let belotPointsEW = 0;
            let regularAnnPointsNS_Raw = 0; let regularAnnPointsEW_Raw = 0;

             ['N', 'S'].forEach(p => {
                 declaredAnnouncements[p].forEach(ann => {
                     if (ann.type === 'BELOT') { belotPointsNS = Math.max(belotPointsNS, ann.points); }
                     else { regularAnnPointsNS_Raw += ann.points; if (compareAnnouncements(ann, highestAnnNS) > 0) { highestAnnNS = ann; } }
                 });
             });
             ['E', 'W'].forEach(p => {
                  declaredAnnouncements[p].forEach(ann => {
                      if (ann.type === 'BELOT') { belotPointsEW = Math.max(belotPointsEW, ann.points); }
                      else { regularAnnPointsEW_Raw += ann.points; if (compareAnnouncements(ann, highestAnnEW) > 0) { highestAnnEW = ann; } }
                  });
             });

            let nsGetsRegularAnns = false;
            let ewGetsRegularAnns = false;
            const comparisonResult = compareAnnouncements(highestAnnNS, highestAnnEW);
            if (comparisonResult > 0) { nsGetsRegularAnns = true; initialMessage = `Ние печелим анонсите (${highestAnnNS.name}).`; }
            else if (comparisonResult < 0) { ewGetsRegularAnns = true; initialMessage = `Те печелят анонсите (${highestAnnEW.name}).`; }
            else if (highestAnnNS) { initialMessage = "Равни анонси - без точки (освен Белот)."; }
            else { initialMessage = "Няма редовни анонси."; }

            const finalAnnPointsNS = belotPointsNS + (nsGetsRegularAnns ? regularAnnPointsNS_Raw : 0);
            const finalAnnPointsEW = belotPointsEW + (ewGetsRegularAnns ? regularAnnPointsEW_Raw : 0);

            // --- 2. Проверка за Капо ---
            let isCapot = false;
            let capotTeam = null;
            if (trickHistory.length === 8) {
                 if (trickHistory.every(t => t.winner === 'N' || t.winner === 'S')) { isCapot = true; capotTeam = 'NS'; }
                 else if (trickHistory.every(t => t.winner === 'E' || t.winner === 'W')) { isCapot = true; capotTeam = 'EW'; }
            }

            // --- 3. Изчисляване на финалните точки за рунда ---
            const biddingTeam = (currentBid.player === 'N' || currentBid.player === 'S') ? 'NS' : 'EW';
            let nsRoundScore = 0; // Инициализация тук, за да е винаги дефинирана
            let ewRoundScore = 0; // Инициализация тук, за да е винаги дефинирана
            const trickPointsNS_Raw = roundScores['NS'].points;
            const trickPointsEW_Raw = roundScores['EW'].points;

            if (isCapot) {
                // --- Логика при Капо ---
                const winnerTeam = capotTeam;
                const loserTeam = (winnerTeam === 'NS') ? 'EW' : 'NS';
                const loserWasBidding = loserTeam === biddingTeam;
                let penalty = -10;
                if (loserWasBidding) { penalty = -20; }

                initialMessage += ` КАПО за ${winnerTeam === 'NS' ? 'Нас' : 'Тях'}!`;
                if (loserWasBidding) initialMessage += ` (${loserTeam === 'NS' ? 'Ние' : 'Те'} сме и Вътре!)`;

                if (winnerTeam === 'NS') { nsRoundScore = 9 + Math.round((finalAnnPointsNS * multiplier) / 10); }
                else { ewRoundScore = 9 + Math.round((finalAnnPointsEW * multiplier) / 10); }
                if (loserTeam === 'NS') { nsRoundScore = (penalty * multiplier) + Math.round((finalAnnPointsNS * multiplier) / 10); }
                else { ewRoundScore = (penalty * multiplier) + Math.round((finalAnnPointsEW * multiplier) / 10); }

            } else {
                // --- Нормална игра (без капо) ---

                // --- Сравнение за Вътре/Вън ---
                const pointsForCompareNS = trickPointsNS_Raw + (nsGetsRegularAnns ? regularAnnPointsNS_Raw : 0);
                const pointsForCompareEW = trickPointsEW_Raw + (ewGetsRegularAnns ? regularAnnPointsEW_Raw : 0);
                const biddingTeamCompareTotal = (biddingTeam === 'NS') ? pointsForCompareNS : pointsForCompareEW;
                const defendingTeamCompareTotal = (biddingTeam === 'NS') ? pointsForCompareEW : pointsForCompareNS;
                const isInside = biddingTeamCompareTotal < defendingTeamCompareTotal;

                // --- Закръгляне САМО на точките от взятки ---
                 let roundedNS, roundedEW;
                 if (isNoTrumpGame) { /* ... Логика за закръгляне на 5 ... */
                    roundedNS = Math.round(trickPointsNS_Raw / 5) * 5;
                    roundedEW = Math.round(trickPointsEW_Raw / 5) * 5;
                    const totalRaw = trickPointsNS_Raw + trickPointsEW_Raw;
                    const targetTotal = totalRaw >= 135 ? 140 : 130;
                    if (roundedNS + roundedEW !== targetTotal) { /* Логика за корекция */
                        if (roundedNS + roundedEW > targetTotal) { if (roundedNS > trickPointsNS_Raw && roundedNS >= roundedEW) roundedNS -= 5; else if (roundedEW > trickPointsEW_Raw) roundedEW -= 5; else if(roundedNS >= roundedEW) roundedNS -=5; else roundedEW -=5;}
                        else { if (roundedEW < trickPointsEW_Raw && roundedEW <= roundedNS) roundedEW += 5; else if (roundedNS < trickPointsNS_Raw) roundedNS += 5; else if(roundedEW <= roundedNS) roundedEW +=5; else roundedNS +=5;}
                        if (roundedNS + roundedEW !== targetTotal) console.warn(`NT Rounding Adjust failed: ${roundedNS}+${roundedEW} != ${targetTotal}`);
                    }
                 } else if (isAllTrumpGame) { /* ... Логика за закръгляне при Всичко Коз (проблем на 4) ... */
                     if (trickPointsNS_Raw % 10 === 4) { if (trickPointsNS_Raw <= trickPointsEW_Raw) { roundedNS = Math.ceil(trickPointsNS_Raw / 10) * 10; roundedEW = Math.floor(trickPointsEW_Raw / 10) * 10; } else { roundedEW = Math.ceil(trickPointsEW_Raw / 10) * 10; roundedNS = Math.floor(trickPointsNS_Raw / 10) * 10; } }
                     else { roundedNS = Math.round(trickPointsNS_Raw / 10) * 10; roundedEW = Math.round(trickPointsEW_Raw / 10) * 10; if(roundedNS+roundedEW==250){if(trickPointsNS_Raw%10>trickPointsEW_Raw%10)roundedNS+=10;else roundedEW+=10;} else if(roundedNS+roundedEW==270){if(trickPointsNS_Raw%10<trickPointsEW_Raw%10)roundedNS-=10;else roundedEW-=10;} }
                 } else { /* ... Логика за закръгляне при Коз (проблем на 6) ... */
                     if (trickPointsNS_Raw % 10 === 6) { if (trickPointsNS_Raw <= trickPointsEW_Raw) { roundedNS = Math.ceil(trickPointsNS_Raw / 10) * 10; roundedEW = Math.floor(trickPointsEW_Raw / 10) * 10; } else { roundedEW = Math.ceil(trickPointsEW_Raw / 10) * 10; roundedNS = Math.floor(trickPointsNS_Raw / 10) * 10; } }
                     else { roundedNS = Math.round(trickPointsNS_Raw / 10) * 10; roundedEW = Math.round(trickPointsEW_Raw / 10) * 10; if(roundedNS+roundedEW==150){if(trickPointsNS_Raw%10>trickPointsEW_Raw%10)roundedNS+=10;else roundedEW+=10;} else if(roundedNS+roundedEW==170){if(trickPointsNS_Raw%10<trickPointsEW_Raw%10)roundedNS-=10;else roundedEW-=10;} }
                 }
                 console.log(`Raw trick pts: ${trickPointsNS_Raw}-${trickPointsEW_Raw} -> Rounded: ${roundedNS}-${roundedEW}`);

                // --- Изчисляване на финалния резултат за рунда ---
                if (!isInside) {
                    // --- УСПЕШЕН ДОГОВОР ---
                    initialMessage += ` Успешен договор ${BID_NAMES[trumpSuit]}!`;
                    nsRoundScore = Math.round(((roundedNS + finalAnnPointsNS) * multiplier) / 10);
                    ewRoundScore = Math.round(((roundedEW + finalAnnPointsEW) * multiplier) / 10);
                } else {
                    // --- ВЪТРЕ! ---
                    initialMessage += ` ${biddingTeam === 'NS' ? 'Ние' : 'Те'} сме вътре!`;
                    const penalty = -10 * multiplier; // Наказание за "вътре"

                    if (biddingTeam === 'NS') { // Ние сме Вътре
                         nsRoundScore = penalty + Math.round((finalAnnPointsNS * multiplier) / 10);
                         ewRoundScore = Math.round(((roundedNS + roundedEW + finalAnnPointsEW) * multiplier) / 10); // Те взимат общите ЗАКРЪГЛЕНИ + техните анонси
                    } else { // Те са Вътре
                         ewRoundScore = penalty + Math.round((finalAnnPointsEW * multiplier) / 10);
                         nsRoundScore = Math.round(((roundedNS + roundedEW + finalAnnPointsNS) * multiplier) / 10); // Ние взимаме общите ЗАКРЪГЛЕНИ + нашите анонси
                    }
                }
            } // Край на else (не е капо)

             teamScores['NS'] += nsRoundScore;
             teamScores['EW'] += ewRoundScore;

             updateScoreBoard();
             setMessage(`${initialMessage} | Рез. рунд${isNoTrumpGame ? ' (x2)' : ''}: Ние ${nsRoundScore}, Те ${ewRoundScore}. | Общ: ${teamScores['NS']}-${teamScores['EW']}`);

            // --- Проверка за край на играта (151) ---
             if (teamScores['NS'] >= 151 || teamScores['EW'] >= 151) {
                 gameState = 'GAME_OVER';
                 let winner = "";
                 if (teamScores['NS'] >= 151 && teamScores['EW'] < 151) winner = "Ние (Север/Юг)";
                 else if (teamScores['EW'] >= 151 && teamScores['NS'] < 151) winner = "Те (Изток/Запад)";
                 else if (teamScores['NS'] > teamScores['EW']) winner = "Ние (Север/Юг)";
                 else if (teamScores['EW'] > teamScores['NS']) winner = "Те (Изток/Запад)";
                 else winner = "Равенство!";

                 const roundSummary = messagesEl.textContent.split('|')[0].trim();
                 setMessage(`${roundSummary} | КРАЙ НА ИГРАТА! ${winner} печелят с ${teamScores['NS']} на ${teamScores['EW']}!`);
                 if(startGameBtn) startGameBtn.disabled = false;

             } else {
                 currentDealer = getNextPlayer(currentDealer);
                 setTimeout(startGame, 4000);
             }
         } // Край на endRound
        function wouldWinTrick(cT,cTP,p) { if(cTP.length===0)return!0; const hypo=[...cTP,{player:p,card:cT}]; let winP=findCurrentTrickWinnerHypothetical(hypo); return winP && winP.player===p; }
        function getPartner(p) { const i=PLAYERS.indexOf(p); return PLAYERS[(i+2)%4]; }
        function getPlayerName(nameOrPos) { if (playerNames && playerNames[nameOrPos]) return playerNames[nameOrPos]; if (typeof nameOrPos === 'string' && Object.values(playerNames).includes(nameOrPos)) return nameOrPos; return {S:'Юг',W:'Запад',N:'Север',E:'Изток'}[nameOrPos]||nameOrPos||'X'; }
        function isTrump(c) { if(!c) return false; if(!trumpSuit||trumpSuit=='PASS')return!1; if(trumpSuit=='ALL_TRUMP')return!0; if(trumpSuit=='NO_TRUMP')return!1; const tS=SUITS[trumpSuit]; return c.suit===tS; }
        function getRankValue(c,isT) { const oNT=['7','8','9','J','Q','K','10','A']; const oT=['7','8','Q','K','10','A','9','J']; if(!c || !c.rank) { console.error("Invalid card in getRankValue:", c); return -1;} if (isT || trumpSuit === 'ALL_TRUMP') return oT.indexOf(c.rank); else return oNT.indexOf(c.rank); }
        function getCardPoints(c) { let iT=isTrump(c); if(!c || !c.rank) { console.error("Invalid card in getCardPoints:", c); return 0; } if(trumpSuit=='NO_TRUMP')return POINTS_NO_TRUMP[c.rank]; if(trumpSuit=='ALL_TRUMP')return POINTS_TRUMP[c.rank]; return iT?POINTS_TRUMP[c.rank]:POINTS_NO_TRUMP[c.rank]; }
        // --- КОРИГИРАНА isPlayable (v6.0) ---
        function isPlayable(player, card) {
            if (gameState !== 'PLAYING' || player !== currentPlayer) return false;
            if (!card) { console.error("isPlayable called with invalid card!"); return false; }
            if (currentTrick.length === 0) return true;

            const leadCard = currentTrick[0].card;
            if (!leadCard) { console.error("isPlayable: No lead card!"); return false; }
            const leadSuit = leadCard.suit;
            const playerHand = hands[player];
            if (!playerHand) { console.error(`isPlayable: No hand for ${player}!`); return false; }

            const isAllTrumpGame = trumpSuit === 'ALL_TRUMP';
            const hasLeadSuit = playerHand.some(c => c && c.suit === leadSuit);

            if (hasLeadSuit) {
                // ---- ТРЯБВА ДА СЛЕДВА БОЯТА ----
                if (card.suit !== leadSuit) return false;

                // ---- Трябва ли да качи (с карта от ИСКАНАТА боя)? ----
                const currentWinningPlay = findCurrentTrickWinner();
                if (currentWinningPlay && currentWinningPlay.card) {
                    const winningCard = currentWinningPlay.card;
                    const useTrumpRankingForWinComp = isAllTrumpGame || isTrump(winningCard);
                    const winningValue = getRankValue(winningCard, useTrumpRankingForWinComp);
                    const cardIsEffectivelyTrump = isAllTrumpGame || isTrump(card);
                    const cardValue = getRankValue(card, cardIsEffectivelyTrump);

                    // При AllTrump и стандартна игра, АКО ВОДЕЩАТА Е КОЗ -> трябва да се качи
                    if (isAllTrumpGame || isTrump(leadCard)) {
                        const hasHigherInLeadSuit = playerHand.some(c =>
                            c && c.suit === leadSuit &&
                            getRankValue(c, isAllTrumpGame || isTrump(c)) > winningValue
                        );
                        if (hasHigherInLeadSuit && cardValue <= winningValue) {
                            return false; // Трябва да играе по-висока
                        }
                    }
                    // Ако не е AllTrump и водещата НЕ Е коз, не трябва да се качва
                }
                return true; // Валиден ход от боята

            } else {
                // ---- НЯМА ОТ ИСКАНАТА БОЯ ----
                const currentWinningPlay = findCurrentTrickWinner();
                const partner = getPartner(player);

                // *** Проверка за Печеливш Партньор ***
                if (currentWinningPlay && currentWinningPlay.player === partner) {
                    if (!isAllTrumpGame) {
                        const hasAnyTrump = playerHand.some(c => c && isTrump(c));
                        if (hasAnyTrump && (!card || !isTrump(card))) {
                             return false; // Все още трябва да играеш коз, ако имаш
                        }
                    }
                    return true; // Валидно е да не се качва
                }

                // ---- Партньорът НЕ печели ИЛИ няма текущ победител ----

                // *** НОВА ЛОГИКА ЗА ALL TRUMP - OFF SUIT (User Rule) ***
                if (isAllTrumpGame) {
                     // Ако е Всичко Коз и нямаш от боята, НЕ МОЖЕШ да спечелиш
                     // и правилото за качване НЕ ВАЖИ. Можеш да играеш ВСЯКА карта.
                     console.log(`isPlayable OK [AllTrump/NoFollow/UserRule]: Playing any card ${card.id} allowed.`);      
                     return true;
                } else {
                    // ---- СТАНДАРТНА ИГРА С КОЗ (НЯМАШ от боята) ----
                    const hasAnyTrump = playerHand.some(c => c && isTrump(c));
                    if (hasAnyTrump) {
                        if (!card || !isTrump(card)) return false; // Трябва да играе коз

                        // Трябва ли да качи коза?
                        if (currentWinningPlay && currentWinningPlay.card && isTrump(currentWinningPlay.card)) {
                            const winningValue = getRankValue(currentWinningPlay.card, true);
                            const hasHigherTrump = playerHand.some(c =>
                                c && isTrump(c) && getRankValue(c, true) > winningValue
                            );
                            if (hasHigherTrump && getRankValue(card, true) <= winningValue) {
                                return false;
                            }
                        }
                        return true; // Валиден коз
                    } else {
                        return true; // Няма коз, играе всичко
                    }
                }
            }
       } // Край на isPlayable
        function findCurrentTrickWinner() { return findCurrentTrickWinnerHypothetical(currentTrick); }
        // --- КОРИГИРАНА findCurrentTrickWinnerHypothetical (v6.0 - Custom AllTrump) ---
        function findCurrentTrickWinnerHypothetical(tP) {
            if (!tP || tP.length === 0) return null;
            let winningPlay = tP[0];
            if (!winningPlay || !winningPlay.card) { console.error("Invalid first play in trick", tP); return null;}
            let trickSuit = winningPlay.card.suit; // Водещата боя ЗАПОМНЯМЕ!

            const isAllTrumpGame = trumpSuit === 'ALL_TRUMP';

            for (let i = 1; i < tP.length; i++) {
                const currentPlay = tP[i];
                const winningCard = winningPlay.card;
                const currentCard = currentPlay.card;
                if (!winningCard || !currentCard) { console.error("Invalid card in hypothetical trick:", tP); continue; }

                if (isAllTrumpGame) {
                    // ---- ЛОГИКА ЗА ALL TRUMP (по user rule) ----
                    // Само карта от ВОДЕЩАТА боя (trickSuit) може да спечели.
                    if (currentCard.suit === trickSuit) {
                        // Ако и двете са от водещата боя, сравняваме по козов ранг
                        if (winningCard.suit === trickSuit) {
                             // Сравняваме силата винаги като коз при AllTrump
                             if (getRankValue(currentCard, true) > getRankValue(winningCard, true)) {
                                winningPlay = currentPlay;
                             }
                        } else {
                            // Ако текущата е от водещата, а печелившата досега НЕ Е, текущата печели
                            winningPlay = currentPlay;
                        }
                    }
                    // Ако currentCard НЕ Е от водещата боя, тя НЕ МОЖЕ да спечели.

                } else {
                    // ---- Стандартна логика за игра с коз или без коз ----
                    const wIT = isTrump(winningCard);
                    const cIT = isTrump(currentCard);
                    const wRV = getRankValue(winningCard, wIT);
                    const cRV = getRankValue(currentCard, cIT);

                    if (cIT && !wIT) winningPlay = currentPlay;
                    else if (cIT && wIT && cRV > wRV) winningPlay = currentPlay;
                    else if (!cIT && !wIT && currentCard.suit === trickSuit && cRV > wRV) winningPlay = currentPlay;
                }
            }
            return winningPlay;
       }

        // --- Мултиплейър Функции ---
        function initializeMultiplayerElements() { roleSelectionEl=document.getElementById('role-selection'); playerNameInputEl=document.getElementById('player-name-input'); becomeHostBtnEl=document.getElementById('become-host-btn'); becomeGuestBtnEl=document.getElementById('become-guest-btn'); hostPanelEl=document.getElementById('host-panel'); hostPeerIdDisplayEl=document.getElementById('host-peer-id-display'); copyHostIdBtnEl=document.getElementById('copy-host-id-btn'); connectedGuestsCountEl=document.getElementById('connected-guests-count'); guestListEl=document.getElementById('guest-list'); mpStartGameBtnEl=document.getElementById('mp-start-game-btn'); guestPanelEl=document.getElementById('guest-panel'); hostIdInputEl=document.getElementById('host-id-input'); connectToHostBtnEl=document.getElementById('connect-to-host-btn'); mpConnectionStatusEl=document.getElementById('mp-connection-status'); if(!becomeHostBtnEl||!becomeGuestBtnEl||!connectToHostBtnEl||!mpStartGameBtnEl||!copyHostIdBtnEl){console.error("MP Buttons missing!");if(mpConnectionStatusEl)mpConnectionStatusEl.textContent="Грешка UI MP.";return;} becomeHostBtnEl.onclick=setupHostPeerJS; becomeGuestBtnEl.onclick=setupGuestPeerJS; connectToHostBtnEl.onclick=connectToHost; mpStartGameBtnEl.onclick=()=>{if(isHost&&connectedGuestsCount===3){assignPlayerPositionsAndStart();}}; copyHostIdBtnEl.onclick=()=>{if(myPeerId&&navigator.clipboard){navigator.clipboard.writeText(myPeerId).then(()=>alert("Peer ID копиран!")).catch(err=>{console.error('Copy failed: ',err);prompt("Копирайте ръчно:",myPeerId);});}else if(myPeerId){prompt("Копирайте ръчно:",myPeerId);}}; }
        function setupHostPeerJS() { myPlayerName=playerNameInputEl.value.trim()||`Хост${Math.floor(Math.random()*100)}`; if(!myPlayerName){alert("Въведете име.");return;} isHost=!0; gameMode='MULTIPLAYER_HOST'; roleSelectionEl.style.display='none'; hostPanelEl.style.display='block'; mpConnectionStatusEl.textContent="Инициализация PeerJS..."; peer=new Peer(); peer.on('open',id=>{myPeerId=id;playerNames[myPeerId]=myPlayerName;console.log('Host PeerID:',myPeerId);hostPeerIdDisplayEl.textContent=myPeerId;mpConnectionStatusEl.textContent=`Стая: ${myPeerId}. Чакане...`;}); peer.on('connection',conn=>{if(connectedGuestsCount>=3){console.warn("Max guests. Rejecting",conn.peer);conn.send({type:"ERROR",message:"Стаята пълна."});setTimeout(()=>conn.close(),500);return;} console.log('Guest trying to connect:',conn.peer);guestConnections[conn.peer]=conn;connectedGuestsCount++;connectedGuestsCountEl.textContent=connectedGuestsCount;const li=document.createElement('li');li.id=`guest-${conn.peer}`;li.textContent=`Гост ${conn.peer} (свързване...)`;guestListEl.appendChild(li);mpConnectionStatusEl.textContent=`${connectedGuestsCount}/3 гости.`;if(connectedGuestsCount===3){mpStartGameBtnEl.disabled=!1;mpConnectionStatusEl.textContent="Всички свързани! Старт от хоста.";} setupPeerDataEvents(conn,conn.peer);}); peer.on('error',err=>{console.error('PeerJS Host Error:',err); alert(`PeerJS Грешка: ${err.message || err.type}`);}); peer.on('disconnected',()=>{mpConnectionStatusEl.textContent="PeerJS сървър прекъснат.";});}
        function setupGuestPeerJS() { myPlayerName=playerNameInputEl.value.trim()||`Гост${Math.floor(Math.random()*100)}`; if(!myPlayerName){alert("Въведете име.");return;} isHost=!1; gameMode='MULTIPLAYER_GUEST'; roleSelectionEl.style.display='none'; guestPanelEl.style.display='block'; mpConnectionStatusEl.textContent="Въведете код на стая.";}
        function connectToHost() { const hostId=hostIdInputEl.value.trim(); if(!hostId){alert("Въведете код.");return;} mpConnectionStatusEl.textContent=`Свързване към ${hostId}...`; if(peer)peer.destroy(); peer=new Peer(); peer.on('open',id=>{myPeerId=id;playerNames[myPeerId]=myPlayerName;console.log('Guest PeerID:',myPeerId,"Connecting to:",hostId);const conn=peer.connect(hostId,{reliable:!0});hostConnection=conn;setupPeerDataEvents(conn,hostId);}); peer.on('error',err=>{mpConnectionStatusEl.textContent=`Грешка свързване: ${err.type}`;console.error(err);});}
        function setupPeerDataEvents(conn,remotePeerId){conn.on('open',()=>{console.log(`Data conn OPEN with ${remotePeerId}`);if(isHost){const li=document.getElementById(`guest-${remotePeerId}`);if(li)li.textContent=`Гост ${remotePeerId} (свързан)`;conn.send({type:"HANDSHAKE_REQUEST",hostName:myPlayerName,hostPeerId:myPeerId});}else{mpConnectionStatusEl.textContent=`Свързан с Хост ${remotePeerId}.`;}}); conn.on('data',data=>{console.log(`Data from ${remotePeerId}:`,data);if(data.type==="HANDSHAKE_REQUEST"&&!isHost){playerNames[data.hostPeerId]=data.hostName;conn.send({type:"HANDSHAKE_RESPONSE",guestName:myPlayerName,guestPeerId:myPeerId});setMessage(`Свързан с хост ${data.hostName}. Чакане...`);}else if(data.type==="HANDSHAKE_RESPONSE"&&isHost){playerNames[data.guestPeerId]=data.guestName;const li=document.getElementById(`guest-${data.guestPeerId}`);if(li)li.textContent=`Гост: ${data.guestName} (${data.guestPeerId})`;}else{handleNetworkMessage(data,remotePeerId);}}); conn.on('close',()=>{console.log(`Data conn CLOSED with ${remotePeerId}`);mpConnectionStatusEl.textContent=`Връзка с ${remotePeerId} прекъсната.`;if(isHost){delete guestConnections[remotePeerId];delete playerNames[remotePeerId];delete playerPeerIds[Object.keys(playerPeerIds).find(pos => playerPeerIds[pos] === remotePeerId)]; connectedGuestsCount--;connectedGuestsCountEl.textContent=connectedGuestsCount;const li=document.getElementById(`guest-${remotePeerId}`);if(li)li.remove();if(connectedGuestsCount<3)mpStartGameBtnEl.disabled=!0;broadcastToGuests({type:"PLAYER_LEFT",peerId:remotePeerId},remotePeerId);}else{alert("Връзка с хоста прекъсната!");roleSelectionEl.style.display='block';guestPanelEl.style.display='none';hostPanelEl.style.display='none';if(mpStartGameBtnEl)mpStartGameBtnEl.disabled=!0; if(gameContainerEl) gameContainerEl.style.display='none';}}); conn.on('error',err=>{console.error(`PeerJS Conn Error with ${remotePeerId}:`,err);mpConnectionStatusEl.textContent=`Грешка връзка с ${remotePeerId}.`;});}
        function broadcastToAll(data){if(isHost){broadcastToGuests(data);handleNetworkMessage(data,myPeerId);}else{console.warn("Guests cannot broadcast.");}}
        function broadcastToGuests(data,excludePeerId=null){if(!isHost)return;console.log("Broadcasting to guests:",data,"Excluding:",excludePeerId);for(const pId in guestConnections){if(pId!==excludePeerId){if(guestConnections[pId]&&guestConnections[pId].open){guestConnections[pId].send(data);}}}}
        function sendToHost(data){if(isHost||!hostConnection||!hostConnection.open){console.warn("Cannot send to host.");return;}console.log("Sending to host:",data);hostConnection.send(data);}
        function assignPlayerPositionsAndStart(){if(!isHost||connectedGuestsCount!==3)return;const guestPIds=Object.keys(guestConnections);playerPositions={S:null,W:null,N:null,E:null};playerPeerIds={};playerPositions['S']=myPeerId;playerPeerIds[myPeerId]='S';playerPositions['W']=guestPIds[0];playerPeerIds[guestPIds[0]]='W';playerPositions['N']=guestPIds[1];playerPeerIds[guestPIds[1]]='N';playerPositions['E']=guestPIds[2];playerPeerIds[guestPIds[2]]='E';console.log("Positions:",playerPositions,"PeerIDs by Pos:", playerPeerIds);const posNames={};PLAYERS.forEach(pos=>{const pId=playerPositions[pos];posNames[pos]=playerNames[pId]||`Играч (${pos})`;const nEl=playerAreaEls[pos]?.querySelector('.player-name');if(nEl)nEl.textContent=posNames[pos]+(pos===myPosition?" (Вие)":"");});if(gameContainerEl)gameContainerEl.style.display='flex';if(declaredAnnouncementsDisplayEl)declaredAnnouncementsDisplayEl.style.display='block';if(scoreBoardEl)scoreBoardEl.style.display='block';const connSetupEl=document.querySelector('.connection-setup');if(connSetupEl)connSetupEl.style.display='none';currentDealer='S';const initData={type:"GAME_START_INFO",playerPositions:playerPositions,playerNames:posNames,currentDealer:currentDealer,myPositionForGuest:null};for(const gPId in guestConnections){const gPos=playerPeerIds[gPId];const dataForG={...initData,myPositionForGuest:gPos};sendGameDataToSpecificGuest(gPId,dataForG);} handleNetworkMessage({...initData,myPositionForGuest:'S'},myPeerId);gameState='LOBBY';mpStartGameBtnEl.textContent = "Старт на Рунд"; mpStartGameBtnEl.onclick = startGame; startGame();}
        function sendGameDataToSpecificGuest(gPId,data){if(isHost&&guestConnections[gPId]&&guestConnections[gPId].open){console.log(`Sending to guest ${gPId}:`,data);guestConnections[gPId].send(data);}else{console.warn(`Cannot send to guest ${gPId}.`);}}

        // --- КОРИГИРАНА handleNetworkMessage (v7.2) ---
        function handleNetworkMessage(message, fromPeerId) {
            const senderName = playerNames[playerPeerIds[fromPeerId]] || fromPeerId;
            console.log(`Received P2P message of type ${message.type} from ${senderName} (${fromPeerId}):`, message);

            if (message.type === "HANDSHAKE_RESPONSE" && isHost) {
                if (!playerNames[message.guestPeerId]) {
                    playerNames[message.guestPeerId] = message.guestName;
                    const guestListItem = document.getElementById(`guest-${message.guestPeerId}`);
                    if(guestListItem) guestListItem.textContent = `Гост: ${message.guestName} (${message.guestPeerId})`;
                }
                return;
            }

            switch (message.type) {
                case "GAME_START_INFO":
                    playerPositions = message.playerPositions;
                    playerNames = message.playerNames;
                    currentDealer = message.currentDealer;
                    myPosition = isHost ? 'S' : message.myPositionForGuest;
                    playerPeerIds = {};
                    for(const pos in playerPositions) { playerPeerIds[playerPositions[pos]] = pos; }
                    console.log("My determined position:", myPosition, "All names by position:", playerNames);
                    PLAYERS.forEach(pos => { const nameEl = playerAreaEls[pos]?.querySelector('.player-name'); if (nameEl) { let dN = playerNames[pos] || `Играч (${pos})`; if (pos === myPosition) dN += " (Вие)"; nameEl.textContent = dN; } });
                    if(gameContainerEl) gameContainerEl.style.display = 'flex';
                    if(declaredAnnouncementsDisplayEl) declaredAnnouncementsDisplayEl.style.display = 'block';
                    if(scoreBoardEl) scoreBoardEl.style.display = 'block';
                    const connSetupEl = document.querySelector('.connection-setup');
                    if (connSetupEl) connSetupEl.style.display = 'none';
                    if (!isHost) { setMessage("Играта започва! Изчаква се хостът да раздаде картите..."); }
                    else { setMessage("Играта започна! Раздаване..."); }
                    break;
                case "DEAL_CARDS_PHASE1": hands = message.hands; currentDealer = message.dealer; gameState = 'BIDDING'; sortHands(); renderAllHands(); startBidding(); break;
                case "DEAL_CARDS_PHASE2": hands = message.hands; potentialAnnouncements = message.potentialAnnouncements; gameState = 'PLAYING'; sortHands(); renderAllHands(); currentPlayer = getNextPlayer(currentDealer); updatePersistentTrumpInfo(); startPlayingPhase(); break;
                case "PLAYER_BID": // Само хостът получава това
                    if (isHost) {
                        const bidderPosition = playerPeerIds[fromPeerId];
                        if (bidderPosition && bidderPosition === currentPlayer) {
                            console.log(`Host processing PLAYER_BID from ${getPlayerName(playerNames[bidderPosition] || bidderPosition)} (${bidderPosition}), bid: ${message.bid}`);
                            handleBid(bidderPosition, message.bid); // Хостът обработва наддаването
                        } else {
                            console.warn("Host: BID from wrong player/unknown peerId or not their turn. Expected:", currentPlayer, "Got from:", bidderPosition);
                        }
                    }
                    break;
                    case "START_PLAYING_PHASE": // НОВО СЪОБЩЕНИЕ
                    hands = message.hands;
                    potentialAnnouncements = message.potentialAnnouncements;
                    currentPlayer = message.currentPlayer;
                    trumpSuit = message.trumpSuit; // Уверяваме се, че козът е синхронизиран
                    gameState = 'PLAYING';
                    sortHands();
                    renderAllHands();
                    updatePersistentTrumpInfo();
                    startPlayingPhase(); // Тази функция ще извика preparePlayerTurn
                    break;
                    case "DEAL_CARDS_PHASE2": // Този case вече е покрит от START_PLAYING_PHASE, ако го изпращаме така
                                        // но ако го оставим, трябва да прави същото
                    hands = message.hands;
                    potentialAnnouncements = message.potentialAnnouncements;
                    gameState = 'PLAYING';
                    sortHands(); renderAllHands();
                    currentPlayer = getNextPlayer(currentDealer); // Трябва да се изпрати от хоста
                    updatePersistentTrumpInfo();
                    startPlayingPhase();
                    break;

                case "CARD_PLAYED":
                    console.log(`Processing CARD_PLAYED for ${message.playerPos}, card: ${message.card?.id}. MyPos: ${myPosition}`);
                    currentTrick = message.currentTrick;
                    if (hands[message.playerPos] && message.card) {
                        hands[message.playerPos] = hands[message.playerPos].filter(c => c.id !== message.card.id);
                    }
                    renderHand(message.playerPos);
                    renderTrickArea();
                    if (message.belotInfo) { /* ... обработка на белот ... */ }
                    // Гостите чакат SET_CURRENT_PLAYER или TRICK_RESULT
                    break;

                case "SET_CURRENT_PLAYER": // Това е за смяна на ред ПО ВРЕМЕ НА ИГРА НА КАРТИ ИЛИ НАДДАВАНЕ
                    currentPlayer = message.nextPlayer;
                    console.log(`Network: SET_CURRENT_PLAYER to ${currentPlayer}. MyPos: ${myPosition}`);
                    if (gameState === 'BIDDING') {
                        setMessage(`Наддаване: Ред на ${getPlayerName(playerNames[currentPlayer] || currentPlayer)}`);
                        updateCurrentPlayerHighlight();
                        updateBiddingControls();
                    } else if (gameState === 'PLAYING' || gameState === 'SCORING_TRICK') { // Добавено SCORING_TRICK
                         // Ако сме били в SCORING_TRICK, сега преминаваме към PLAYING за новата ръка
                        gameState = 'PLAYING';
                        setMessage(`Игра: Ред ${getPlayerName(playerNames[currentPlayer] || currentPlayer)}.`);
                        updateCurrentPlayerHighlight();
                        preparePlayerTurn();
                    }
                    break;
                case "BID_UPDATE": // Всички получават това
                    currentBid = message.currentHighestBid; // Всички актуализират currentBid
                    biddingHistory = message.biddingHistory;
                    if (message.bidMade !== 'PASS') updatePersistentTrumpInfo(); // UI за коз
                    setMessage(`${getPlayerName(playerNames[message.biddingPlayer] || message.biddingPlayer)} наддаде ${BID_NAMES[message.bidMade]}`);
                    // НЕ сменяме currentPlayer тук, чакаме SET_CURRENT_PLAYER_BID
                    break;
                case "SET_CURRENT_PLAYER_BID": // Преименувано от NEXT_BIDDER за наддаване
                    currentPlayer = message.nextPlayer;
                    setMessage(`Наддаване: Ред на ${getPlayerName(playerNames[currentPlayer] || currentPlayer)}`);
                    updateCurrentPlayerHighlight();
                    updateBiddingControls(); // Това ще покаже бутоните, АКО currentPlayer === myPosition
                    break;
                case "BIDDING_END": // Всички получават това
                    currentBid = message.finalBid; // Всички актуализират финалния бид
                    finalizeBidding(); // Всички извикват finalizeBidding (хостът ще извика dealFinalCards)
                    break;
                case "PLAYER_ANNOUNCEMENTS": if (isHost) { const announcerPosition = message.playerPos; declaredAnnouncements[announcerPosition] = message.announcements; updateDeclaredAnnouncementsDisplay(); broadcastToGuests({type: "ANNOUNCEMENT_DECLARED",playerPos: announcerPosition,announcements: message.announcements, belotDeclaredMessage: null}, playerPositions[announcerPosition]); if (announcerPosition === myPosition) { handleNetworkMessage({type: "ANNOUNCEMENT_DECLARED", playerPos: announcerPosition, announcements: message.announcements, belotDeclaredMessage: null}, myPeerId); } } break;
                case "ANNOUNCEMENT_DECLARED": if (!(isHost && message.playerPos === myPosition && fromPeerId === myPeerId) ) { declaredAnnouncements[message.playerPos] = message.announcements; updateDeclaredAnnouncementsDisplay(); } if(message.belotDeclaredMessage) setMessage(message.belotDeclaredMessage); break;
                case "PLAY_CARD": // Само хостът получава това
                    if (isHost) {
                        const playerPosition = playerPeerIds[fromPeerId];
                        if (playerPosition && playerPosition === currentPlayer) {
                            processPlayedCard(playerPosition, message.cardId);
                        } else { console.warn("Host: PLAY_CARD from wrong player/unknown peerId or not their turn."); }
                    }
                    break;
                case "CARD_PLAYED": // Всички получават това
                    console.log(`Processing CARD_PLAYED for ${message.playerPos}, card: ${message.card?.id}. MyPos: ${myPosition}`);
                    currentTrick = message.currentTrick;
                    if (hands[message.playerPos] && message.card) { hands[message.playerPos] = hands[message.playerPos].filter(c => c.id !== message.card.id); }
                    renderHand(message.playerPos); renderTrickArea();
                    if (message.belotInfo) {
                        if (!(isHost && message.belotInfo.playerPos === myPosition && fromPeerId === myPeerId)) {
                            belotStatus[message.belotInfo.playerPos].declared = true;
                            const belotAnnObject = potentialAnnouncements[message.belotInfo.playerPos]?.find(a => a.type === 'BELOT');
                            if (belotAnnObject && !declaredAnnouncements[message.belotInfo.playerPos].some(a => a.type === 'BELOT')) { declaredAnnouncements[message.belotInfo.playerPos].push(belotAnnObject); }
                            updateDeclaredAnnouncementsDisplay(); setMessage(message.belotInfo.message);
                        }
                    }
                    // Гостите чакат SET_CURRENT_PLAYER (преди беше NEXT_PLAYER_TRICK)
                    break;
                case "SET_CURRENT_PLAYER":
    console.log(`HOST/GUEST (${myPosition}) received SET_CURRENT_PLAYER. Old currentPlayer: ${currentPlayer}, New from message: ${message.nextPlayer}`);
    currentPlayer = message.nextPlayer;
    console.log(`HOST/GUEST (${myPosition}) NEW currentPlayer is now: ${currentPlayer}. My position is: ${myPosition}`);
    setMessage(`Игра: Ред ${getPlayerName(playerNames[currentPlayer] || currentPlayer)}.`);
    updateCurrentPlayerHighlight();
    preparePlayerTurn(); // Това ще извика allowCardPlay, което ще извика updatePlayableCards
    break;
                case "TRICK_RESULT": // Всички получават това
                    roundScores = message.roundScores;
                    setMessage(`${getPlayerName(playerNames[message.winner] || message.winner)} печели с ${cardToString(message.winningCard)}. Точки: ${message.points}${message.isLastTrick?' (+10)':''}`);
                    trickHistory.push({winner:message.winner, trick:message.currentTrickForDisplay || currentTrick, points:message.points}); // Запазваме историята
                    // Показваме взятката, която току-що е приключила (ако е изпратена)
                    if (message.currentTrickForDisplay) {
                        currentTrick = message.currentTrickForDisplay;
                        renderTrickArea();
                    }

                    setTimeout(()=>{
                        clearTrickArea(); // Изчистваме визуално масата
                        currentTrick = [];    // Нулираме данните за текущата взятка **при всички клиенти**

                        if(message.isLastTrick){
                             if(isHost) endRound(); // Само хостът изчислява края на рунда
                             // Гостите чакат ROUND_END_INFO
                        } else {
                             // Взятката НЕ е последна
                             if (isHost) { // Само хостът определя кой е следващия на ход
                                 const nextPlayerAfterTrick = message.winner; // Победителят от взятката започва
                                 // Не задаваме currentPlayer тук, а изпращаме съобщение
                                 // determineNextActionAfterPlay ще се погрижи за това, като изпрати SET_CURRENT_PLAYER
                                 // Вместо това, нека determineNextActionAfterPlay да се извика само след CARD_PLAYED
                                 // и determineTrickWinner да инициира следващия SET_CURRENT_PLAYER
                                 console.log(`Host: Trick ended. Winner ${nextPlayerAfterTrick} starts next trick.`);
                                 // Хостът директно задава новия currentPlayer и изпраща
                                 currentPlayer = nextPlayerAfterTrick;
                                 broadcastToAll({type: "SET_CURRENT_PLAYER", nextPlayer: currentPlayer});
                                 // preparePlayerTurn() ще се извика при всички, когато получат SET_CURRENT_PLAYER
                             }
                             // Гостите просто чакат SET_CURRENT_PLAYER
                        }
                    }, 1800);
                    break;
                case "ROUND_END_INFO": if (!isHost) { teamScores=message.teamScores; updateScoreBoard(); setMessage(message.message); if(message.nextDealer){currentDealer=message.nextDealer; if(message.startNextRound){setMessage("Изчаква се хостът...");}}} break;
                case "GAME_OVER_INFO": if (!isHost) { gameState='GAME_OVER'; teamScores=message.teamScores; updateScoreBoard(); setMessage(message.message); if(roleSelectionEl)roleSelectionEl.style.display='block'; if(hostPanelEl)hostPanelEl.style.display='none'; if(guestPanelEl)guestPanelEl.style.display='none'; if(gameContainerEl)gameContainerEl.style.display='none'; if(declaredAnnouncementsDisplayEl)declaredAnnouncementsDisplayEl.style.display='none'; if(scoreBoardEl)scoreBoardEl.style.display='none'; if(mpStartGameBtnEl)mpStartGameBtnEl.disabled=!0;} break;
                case "PLAYER_LEFT": const leftPN=playerNames[playerPeerIds[message.peerId]]||message.peerId; alert(`Играч ${leftPN} напусна.`); if(isHost){const li=document.getElementById(`guest-${message.peerId}`);if(li)li.textContent+=" (Напусна)";if(mpStartGameBtnEl)mpStartGameBtnEl.disabled=!0;} if(gameMode.startsWith("MULTIPLAYER")){gameState='LOBBY';if(roleSelectionEl)roleSelectionEl.style.display='block';if(hostPanelEl)hostPanelEl.style.display='none';if(guestPanelEl)guestPanelEl.style.display='none';if(gameContainerEl)gameContainerEl.style.display='none';if(declaredAnnouncementsDisplayEl)declaredAnnouncementsDisplayEl.style.display='none';if(scoreBoardEl)scoreBoardEl.style.display='none';if(mpConnectionStatusEl)mpConnectionStatusEl.textContent="Играч напусна.";if(peer&&!isHost)peer.destroy();if(peer&&isHost&&connectedGuestsCount===0)peer.destroy();} break;
                default: console.warn("Unknown message type:", message.type);
            }
        } // Край на handleNetworkMessage

        function sendToHostOrBroadcast(data) { if(gameMode==='MULTIPLAYER_GUEST'){sendToHost(data);}else if(gameMode==='MULTIPLAYER_HOST'){broadcastToAll(data);}}

        // --- Инициализация ---
        function startGame() {
            console.log("startGame function entered! GameMode:", gameMode, "IsHost:", isHost);
            if (!messagesEl) { console.error("startGame: messagesEl not ready!"); return; }
            setMessage("Подготовка за нов рунд...");
            if (gameMode.startsWith('MULTIPLAYER') && mpStartGameBtnEl) { mpStartGameBtnEl.disabled = true; }

            gameState = 'INIT_ROUND';
            if(typeof clearCurrentPlayerHighlight === 'function') clearCurrentPlayerHighlight(); else console.error("clearCurrentPlayerHighlight undefined");
            if(typeof hideBiddingControls === 'function') hideBiddingControls(); else console.error("hideBiddingControls undefined");
            if(typeof hideAnnouncementModal === 'function') hideAnnouncementModal(); else console.error("hideAnnouncementModal undefined");
            if(declaredAnnouncementsDisplayEl) declaredAnnouncementsDisplayEl.style.display = 'block';
            if(declaredAnnouncementsListEl) declaredAnnouncementsListEl.innerHTML = 'Няма обявени анонси в този рунд.';
            trickHistory = []; currentTrick = [];
            potentialAnnouncements = {S:[],W:[],N:[],E:[]}; declaredAnnouncements = {S:[],W:[],N:[],E:[]};
            playerDeclaredFlags = {S:!1,W:!1,N:!1,E:!1};
            belotStatus = {S:{hasKQ:!1,declared:!1},W:{hasKQ:!1,declared:!1},N:{hasKQ:!1,declared:!1},E:{hasKQ:!1,declared:!1}};
            roundScores = {NS:{points:0,announcements:0},EW:{points:0,announcements:0}};

            if (isHost || gameMode === 'LOCAL') {
                try {
                    console.log("startGame (Host/Local): Initializing round state...");
                    if (typeof createDeck !== 'function') throw new Error("createDeck is not a function"); createDeck();
                    if (typeof shuffleDeck !== 'function') throw new Error("shuffleDeck is not a function"); shuffleDeck();
                    if (typeof cutDeck !== 'function') throw new Error("cutDeck is not a function"); cutDeck();
                    if (typeof dealInitialCards !== 'function') throw new Error("dealInitialCards is not a function"); dealInitialCards();
                    // updateScoreBoard(); // Не нулираме общия резултат тук, само при нова игра
                } catch (error) { console.error("CRITICAL Error during round initialization:", error); setMessage(`Грешка: ${error.message}.`); if (gameMode.startsWith('MULTIPLAYER') && mpStartGameBtnEl) mpStartGameBtnEl.disabled = false; return; }
                console.log("startGame (Host/Local) round init finished successfully.");
            } else {
                console.log("startGame (Guest): Waiting for host to deal cards for new round.");
                setMessage("Изчаква се хостът да раздаде картите за новия рунд...");
            }
        }

        // --- Event Listeners и Първоначално състояние ---
         // --- Event Listeners и Първоначално състояние ---
         document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded and parsed (v7.1 - DOM Check Fix)");

            // Присвояване на DOM елементите...
            persistentTrumpInfoEl = document.getElementById('persistent-trump-info');
            playerAreaEls = {
                S: document.getElementById('player-area-S'),
                W: document.getElementById('player-area-W'),
                N: document.getElementById('player-area-N'),
                E: document.getElementById('player-area-E')
            };
            playerHands = {
                S: document.getElementById('hand-S'),
                W: document.getElementById('hand-W'),
                N: document.getElementById('hand-N'),
                E: document.getElementById('hand-E')
            };
            trickAreaEl = document.getElementById('trick-area');
            trickCardSlots = {
                S: document.getElementById('trick-slot-S'),
                W: document.getElementById('trick-slot-W'),
                N: document.getElementById('trick-slot-N'),
                E: document.getElementById('trick-slot-E')
            };
            controlsAreaEl = document.getElementById('controls-area');
            controlsButtonsEl = document.getElementById('controls-buttons');
            declaredAnnouncementsDisplayEl = document.getElementById('declared-announcements-display');
            declaredAnnouncementsListEl = document.getElementById('declared-announcements-list');
            messagesEl = document.getElementById('messages');
            scoreBoardEl = document.getElementById('score-board');
            announcementModal = document.getElementById('announcementModal');
            modalAnnouncementsList = document.getElementById('modal-announcement-list');
            modalConfirmBtn = document.getElementById('modal-confirm-btn');
            gameContainerEl = document.querySelector('.game-container');

            // Мултиплейър UI елементи
            roleSelectionEl = document.getElementById('role-selection');
            playerNameInputEl = document.getElementById('player-name-input');
            becomeHostBtnEl = document.getElementById('become-host-btn');
            becomeGuestBtnEl = document.getElementById('become-guest-btn');
            hostPanelEl = document.getElementById('host-panel');
            hostPeerIdDisplayEl = document.getElementById('host-peer-id-display');
            copyHostIdBtnEl = document.getElementById('copy-host-id-btn');
            connectedGuestsCountEl = document.getElementById('connected-guests-count');
            guestListEl = document.getElementById('guest-list');
            mpStartGameBtnEl = document.getElementById('mp-start-game-btn');
            guestPanelEl = document.getElementById('guest-panel');
            hostIdInputEl = document.getElementById('host-id-input');
            connectToHostBtnEl = document.getElementById('connect-to-host-btn');
            mpConnectionStatusEl = document.getElementById('mp-connection-status');

            console.log("DOM elements assigned.");

            // --- Коригирана Проверка за критични DOM елементи ---
            const elementsToCheck = {
                persistentTrumpInfoEl, playerAreaS: playerAreaEls.S, playerAreaW: playerAreaEls.W, playerAreaN: playerAreaEls.N, playerAreaE: playerAreaEls.E,
                playerHandS: playerHands.S, playerHandW: playerHands.W, playerHandN: playerHands.N, playerHandE: playerHands.E,
                trickAreaEl, trickSlotS: trickCardSlots.S, trickSlotW: trickCardSlots.W, trickSlotN: trickCardSlots.N, trickSlotE: trickCardSlots.E,
                controlsAreaEl, controlsButtonsEl, declaredAnnouncementsDisplayEl, declaredAnnouncementsListEl,
                messagesEl, scoreBoardEl, announcementModal, modalAnnouncementsList, modalConfirmBtn,
                roleSelectionEl, playerNameInputEl, becomeHostBtnEl, becomeGuestBtnEl, hostPanelEl,
                hostPeerIdDisplayEl, copyHostIdBtnEl, connectedGuestsCountEl, guestListEl, mpStartGameBtnEl,
                guestPanelEl, hostIdInputEl, connectToHostBtnEl, mpConnectionStatusEl, gameContainerEl
            };

            let missingElementName = null;
            for (const name in elementsToCheck) {
                if (!elementsToCheck[name]) {
                    missingElementName = name;
                    break;
                }
            }

            if (missingElementName) {
                 console.error(`Critical DOM element "${missingElementName}" was not found!`);
                 alert(`Грешка: Елемент "${missingElementName}" не е намерен! Проверете HTML и ID-тата. Презаредете страницата.`);
                 return; // Спираме по-нататъшното изпълнение
            }
            // --- Край на коригираната проверка ---

            initializeMultiplayerElements(); // Сега това трябва да е дефинирано и елементите налични

            // Първоначално състояние
            setMessage("Изберете роля (Хост/Гост).");
            updateScoreBoard();
            renderAllHands(); // Ще покаже празни полета
            clearCurrentPlayerHighlight();
            updatePersistentTrumpInfo();
            hideBiddingControls();
            if(declaredAnnouncementsDisplayEl) declaredAnnouncementsDisplayEl.style.display = 'none';
            if(scoreBoardEl) scoreBoardEl.style.display = 'none';
            if(gameContainerEl) gameContainerEl.style.display = 'none';

            console.log("Initial setup complete.");
        });

    </script>
</body>
</html>
