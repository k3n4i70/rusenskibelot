<!DOCTYPE html>
<html lang="bg">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Белот Русе P2P (Демо v7.0 - Пълен Код)</title>
    <style>
        /* --- Основни Стилове --- */
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; background-color: #f0f0f0; margin: 0; padding: 10px; min-height: 100vh; box-sizing: border-box; }
        .game-container { background-color: #2a6a2a; border: 5px solid #5d3a1a; border-radius: 10px; padding: 15px; width: 95%; max-width: 800px; box-shadow: 0 0 15px rgba(0, 0, 0, 0.5); position: relative; aspect-ratio: 4 / 3; display: flex; flex-direction: column; justify-content: space-between; overflow: hidden; }
        .persistent-trump { position: absolute; top: 10px; right: 10px; background-color: rgba(0, 0, 0, 0.6); color: white; padding: 5px 10px; border-radius: 5px; font-size: 0.9em; z-index: 50; text-align: right; max-width: 150px; }
        .persistent-trump .suit { font-size: 1.3em; font-weight: bold; }
        .persistent-trump .suit.spades, .persistent-trump .suit.clubs { color: white; text-shadow: 1px 1px 1px black; }
        .persistent-trump .suit.hearts, .persistent-trump .suit.diamonds { color: #ffcccc; text-shadow: 1px 1px 1px darkred; }
        .player-area { display: flex; align-items: center; position: absolute; min-width: 80px; min-height: 70px; background: rgba(255, 255, 255, 0.1); border-radius: 5px; padding: 5px; transition: box-shadow 0.3s ease; z-index: 20; }
        .player-area.current-player { box-shadow: 0 0 15px 5px yellow; }
        .player-south { bottom: 10px; left: 50%; transform: translateX(-50%); flex-direction: column; align-items: center; width: 80%; }
        .player-west { left: 10px; top: 50%; transform: translateY(-50%); flex-direction: column; align-items: flex-start; }
        .player-north { top: 10px; left: 50%; transform: translateX(-50%); flex-direction: column-reverse; align-items: center; }
        .player-east { right: 10px; top: 50%; transform: translateY(-50%); flex-direction: column; align-items: flex-end; }
        .player-name { font-weight: bold; color: white; margin-bottom: 5px; font-size: 0.9em; text-shadow: 1px 1px 2px black; }
        .hand { display: flex; flex-wrap: wrap; gap: 2px; justify-content: center; min-height: 50px; }
        .player-west .hand, .player-east .hand { flex-direction: column; gap: 1px; }
        .card { border: 1px solid black; border-radius: 5px; padding: 5px; min-width: 40px; min-height: 60px; background-color: white; display: inline-flex; flex-direction: column; justify-content: space-between; align-items: center; font-size: 1em; cursor: default; box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3); position: relative; user-select: none; transition: transform 0.2s ease, box-shadow 0.2s ease, border 0.2s ease; }
        .card.playable { cursor: pointer; border: 2px solid yellow; box-shadow: 0 0 10px yellow; }
        .card.playable:hover { transform: translateY(-10px); }
        .card span { display: block; text-align: center; font-weight: bold; }
        .card .rank { font-size: 1.2em; }
        .card .suit { font-size: 1.5em; }
        .card.spades .suit, .card.clubs .suit { color: black; }
        .card.hearts .suit, .card.diamonds .suit { color: red; }
        .card.hidden { background-color: #b0b0b0; background-image: repeating-linear-gradient(45deg, #a0a0a0, #a0a0a0 5px, #b0b0b0 5px, #b0b0b0 10px ); color: transparent; box-shadow: none; border: 1px solid #777; }
        .player-west .card.hidden, .player-east .card.hidden { min-width: 20px; min-height: 60px; }
        .player-north .card.hidden { min-width: 40px; min-height: 30px; }
        .trick-area { position: absolute; top: 20%; left: 15%; width: 70%; height: 60%; pointer-events: none; z-index: 10; }
        .trick-card-slot { position: absolute; transform: translate(-50%, -50%); }
        .trick-card-slot.player-S { top: 75%; left: 50%; }
        .trick-card-slot.player-W { top: 50%; left: 25%; }
        .trick-card-slot.player-N { top: 25%; left: 50%; }
        .trick-card-slot.player-E { top: 50%; left: 75%; }
        .controls-area { position: absolute; bottom: calc(10px + 70px + 10px); left: 50%; transform: translateX(-50%); background: rgba(255, 255, 255, 0.8); padding: 10px; border-radius: 5px; text-align: center; z-index: 60; display: none; }
        .controls-area.visible { display: block; }
        .controls-area button { padding: 8px 15px; margin: 5px; font-size: 1em; cursor: pointer; border: none; border-radius: 5px; background-color: #4CAF50; color: white; transition: background-color 0.2s ease; }
        .controls-area button:hover:not(:disabled) { background-color: #45a049; }
        .controls-area button:disabled { background-color: #cccccc; cursor: not-allowed; }
        .controls-area button.pass { background-color: #f44336; }
        .controls-area button.pass:hover:not(:disabled) { background-color: #da190b; }
        .controls-area button.bid { background-color: #2196F3; }
        .controls-area button.bid:hover:not(:disabled) { background-color: #0b7dda; }
        .announcements, .messages, .score-board { margin-top: 10px; background: rgba(255, 255, 255, 0.8); padding: 10px; border-radius: 5px; text-align: center; width: 90%; max-width: 600px; }
        .announcements { min-height: 50px; text-align: left; }
        .announcements p { text-align: center; margin-bottom: 5px; font-weight: bold; }
        .declared-announcement-item { margin: 2px 0; padding: 3px; border-bottom: 1px dotted #ccc; font-size: 0.9em; }
        .declared-announcement-item:last-child { border-bottom: none; }
        .messages { min-height: 40px; font-weight: bold; color: #333; }
        .score-board { font-size: 1.1em; }
        .modal { display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); padding-top: 60px; }
        .modal-content { background-color: #fefefe; margin: 5% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 500px; border-radius: 8px; text-align: center; }
        .modal-content h3 { margin-top: 0; }
        .modal-announcement-list label { display: block; margin: 8px 0; cursor: pointer; padding: 5px; border: 1px solid #eee; border-radius: 4px; }
        .modal-announcement-list label:hover { background-color: #f0f0f0; }
        .modal-announcement-list input[type="checkbox"] { margin-right: 10px; }
        .modal-close-btn { margin-top: 15px; padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 1em; }
        .modal-close-btn:hover { background-color: #45a049; }

        .connection-setup { border: 1px solid #ccc; padding: 15px; margin: 20px auto; width: 90%; max-width: 600px; background-color: #f9f9f9; border-radius: 8px; text-align: center; }
        .connection-setup h2 { margin-top: 0; }
        .connection-setup input[type="text"],
        .connection-setup button { padding: 8px; margin: 5px; border-radius: 4px; border: 1px solid #ddd; }
        .connection-setup button { background-color: #5cb85c; color: white; cursor: pointer; }
        .connection-setup button:hover { background-color: #4cae4c; }
        #host-panel, #guest-panel { margin-top: 15px; padding: 10px; border: 1px dashed #aaa; }
        #guest-list { list-style: none; padding-left: 0; text-align: left;}
        #guest-list li { padding: 3px; border-bottom: 1px solid #eee; }
        #guest-list li:last-child { border-bottom: none; }

        @media (max-width: 600px) { /* ... */ }
        @media (max-width: 400px) { /* ... */ }
    </style>
</head>
<body>

    <h1>Белот Русе P2P (Демо v7.0)</h1>

    <div class="connection-setup">
        <h2>Мултиплейър за 4 Играча</h2>
        <div id="role-selection">
            <input type="text" id="player-name-input" placeholder="Вашето име" value="Играч">
            <button id="become-host-btn">Аз съм Хост</button>
            <button id="become-guest-btn">Аз съм Гост</button>
        </div>

        <div id="host-panel" style="display:none;">
            <h3>Вие сте Хост</h3>
            <p>Споделете този Код на Стаята (Вашият Peer ID) с другите 3 играча:</p>
            <p>
                <strong id="host-peer-id-display" style="font-size: 1.2em; background: #eee; padding: 5px;">Зареждане...</strong>
                <button id="copy-host-id-btn" style="margin-left: 10px;">Копирай</button>
            </p>
            <p>Свързани гости: <span id="connected-guests-count">0</span>/3</p>
            <h4>Списък на гостите:</h4>
            <ul id="guest-list"></ul>
            <button id="mp-start-game-btn" disabled>Старт на Играта (Нужни са 3 госта)</button>
        </div>

        <div id="guest-panel" style="display:none;">
            <h3>Вие сте Гост</h3>
            <p>Въведете Кода на Стаята (Peer ID на Хоста):</p>
            <input type="text" id="host-id-input" placeholder="Код от Хоста">
            <button id="connect-to-host-btn">Свържи се с Хоста</button>
        </div>
        <div id="mp-connection-status" style="margin-top:10px; font-weight: bold;">Статус: Изберете роля.</div>
    </div>


    <div class="game-container" style="display:none;">
         <div id="persistent-trump-info" class="persistent-trump">Коз: N/A</div>
         <div id="player-area-N" class="player-area player-north"><div class="player-name">Север</div><div class="hand" id="hand-N"></div></div>
         <div id="player-area-E" class="player-area player-east"><div class="player-name">Изток</div><div class="hand" id="hand-E"></div></div>
         <div id="player-area-S" class="player-area player-south"><div class="hand" id="hand-S"></div><div class="player-name">Юг (Вие)</div></div>
         <div id="player-area-W" class="player-area player-west"><div class="player-name">Запад</div><div class="hand" id="hand-W"></div></div>
         <div class="trick-area" id="trick-area"> <div id="trick-slot-S" class="trick-card-slot player-S"></div> <div id="trick-slot-W" class="trick-card-slot player-W"></div> <div id="trick-slot-N" class="trick-card-slot player-N"></div> <div id="trick-slot-E" class="trick-card-slot player-E"></div> </div>
         <div class="controls-area" id="controls-area"> <p>Вашият ход:</p> <div id="controls-buttons"></div> </div>
    </div>

    <div class="announcements" id="declared-announcements-display" style="display:none;"> <p>Обявени Анонси:</p> <div id="declared-announcements-list">Няма обявени анонси в този рунд.</div> </div>
    <div class="messages" id="messages">Изберете роля, за да започнете.</div>
    <div class="score-board" id="score-board" style="display:none;">Резултат: Ние: 0 - Те: 0</div>
    <!-- <div style="margin-top: 10px;"> <button id="start-game-btn">Старт Локална Игра</button> </div> -->
    <div id="announcementModal" class="modal"> <div class="modal-content"> <h3>Обявете вашите анонси (първа ръка):</h3> <div id="modal-announcement-list" class="modal-announcement-list"></div> <button id="modal-confirm-btn" class="modal-close-btn">Потвърди и играй</button> </div> </div>

    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script>
        // --- Константи и Глобални Променливи ---
        const SUITS = { SPADES: '♠', HEARTS: '♥', DIAMONDS: '♦', CLUBS: '♣' };
        const SUIT_KEYS = Object.keys(SUITS);
        const RANKS = ['7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const PLAYERS = ['S', 'W', 'N', 'E']; // Юг, Запад, Север, Изток
        const POINTS_NO_TRUMP = { '7': 0, '8': 0, '9': 0, '10': 10, 'J': 2, 'Q': 3, 'K': 4, 'A': 11 };
        const POINTS_TRUMP    = { '7': 0, '8': 0, '9': 14, '10': 10, 'J': 20, 'Q': 3, 'K': 4, 'A': 11 };
        const RANK_ORDER_FOR_SEQ = ['7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const ANNOUNCEMENTS_DEF = {
            'BELOT':   { value: 10, points: 20, name: "Белот" },
            'TERCA':   { value: 20, points: 20, name: "Терца", rankValue: -1 },
            'QUARTA':  { value: 30, points: 50, name: "Кварта", rankValue: -1 },
            'QUINTA':  { value: 40, points: 100, name: "Квинта", rankValue: -1 },
            'SQ_7':    { value: 15, points: 0, name: "4x7", rankValue: RANK_ORDER_FOR_SEQ.indexOf('7') },
            'SQ_8':    { value: 15, points: 0, name: "4x8", rankValue: RANK_ORDER_FOR_SEQ.indexOf('8') },
            'SQ_9':    { value: 15, points: 0, name: "4x9", rankValue: RANK_ORDER_FOR_SEQ.indexOf('9') },
            'SQ_10':   { value: 50, points: 100, name: "4x10", rankValue: RANK_ORDER_FOR_SEQ.indexOf('10') },
            'SQ_Q':    { value: 50, points: 100, name: "4xQ", rankValue: RANK_ORDER_FOR_SEQ.indexOf('Q') },
            'SQ_K':    { value: 50, points: 100, name: "4xK", rankValue: RANK_ORDER_FOR_SEQ.indexOf('K') },
            'SQ_A':    { value: 60, points: 150, name: "4xA", rankValue: RANK_ORDER_FOR_SEQ.indexOf('A') },
            'SQ_J':    { value: 70, points: 200, name: "4xJ", rankValue: RANK_ORDER_FOR_SEQ.indexOf('J') },
            'SQ_10_NT':{ value: 75, points: 200, name: "4x10 (Без Коз)", rankValue: RANK_ORDER_FOR_SEQ.indexOf('10') },
            'SQ_A_NT': { value: 80, points: 400, name: "4xA (Без Коз)", rankValue: RANK_ORDER_FOR_SEQ.indexOf('A') },
        };
        const BIDS = ['PASS', 'CLUBS', 'DIAMONDS', 'HEARTS', 'SPADES', 'NO_TRUMP', 'ALL_TRUMP'];
        const BID_NAMES = {
            'PASS': 'Пас', 'CLUBS': '♣ Спатия', 'DIAMONDS': '♦ Каро', 'HEARTS': '♥ Купа',
            'SPADES': '♠ Пика', 'NO_TRUMP': 'Без Коз', 'ALL_TRUMP': 'Всичко Коз'
        };

        let deck = [];
        let hands = { 'S': [], 'W': [], 'N': [], 'E': [] };
        let currentDealer = 'S';
        let currentPlayer = '';
        let gameState = 'INIT';
        let currentBid = { player: null, bid: 'PASS', level: -1 };
        let biddingHistory = [];
        let trumpSuit = null;
        let currentTrick = [];
        let trickHistory = [];
        let teamScores = { 'NS': 0, 'EW': 0 };
        let roundScores = { 'NS': { points: 0, announcements: 0 }, 'EW': { points: 0, announcements: 0 } };
        let potentialAnnouncements = { 'S': [], 'W': [], 'N': [], 'E': [] };
        let declaredAnnouncements = { 'S': [], 'W': [], 'N': [], 'E': [] };
        let playerDeclaredFlags = { 'S': false, 'W': false, 'N': false, 'E': false };
        let belotStatus = { S:{hasKQ:!1,declared:!1},W:{hasKQ:!1,declared:!1},N:{hasKQ:!1,declared:!1},E:{hasKQ:!1,declared:!1} };
        let myPosition = null; // Коя позиция съм аз (S, W, N, E)

        // --- Мултиплейър Променливи ---
        let peer;
        let myPeerId = null;
        let isHost = false;
        let gameMode = 'INIT_MP';
        let guestConnections = {};
        let hostConnection = null;
        let connectedGuestsCount = 0;
        let playerNames = {}; // { 'S': 'Име', 'W': 'Име', ... }
        let playerPeerIds = {}; // { 'S': 'peerId', 'W': 'peerId', ... }

        // --- DOM Елементи (Декларации) ---
        let persistentTrumpInfoEl, playerAreaEls, playerHands, trickAreaEl, trickCardSlots,
            controlsAreaEl, controlsButtonsEl, declaredAnnouncementsDisplayEl,
            declaredAnnouncementsListEl, messagesEl, scoreBoardEl,
            announcementModal, modalAnnouncementsList, modalConfirmBtn,
            roleSelectionEl, playerNameInputEl, becomeHostBtnEl, becomeGuestBtnEl,
            hostPanelEl, hostPeerIdDisplayEl, copyHostIdBtnEl, connectedGuestsCountEl, guestListEl, mpStartGameBtnEl,
            guestPanelEl, hostIdInputEl, connectToHostBtnEl,
            mpConnectionStatusEl, gameContainerEl;

        // --- Помощни UI Функции ---
        function setMessage(msg) { console.log("MSG:", msg); if(messagesEl) messagesEl.textContent = msg; else console.warn("setMessage called before messagesEl assigned!"); }
        function updateScoreBoard() { if(scoreBoardEl) scoreBoardEl.textContent = `Резултат: Ние (С/Ю): ${teamScores['NS']} - Те (И/З): ${teamScores['EW']}`; else console.warn("updateScoreBoard called before scoreBoardEl assigned!"); }
        function renderCard(card, isHidden = false, isPlayableCard = false) { if (!card && isHidden) return `<div class="card hidden"></div>`; if (!card || !card.suit || !card.rank || !card.id) { console.error(`renderCard Error: Invalid card!`, card); return '<div class="card error">?</div>'; } const suitKey = Object.keys(SUITS).find(key => SUITS[key] === card.suit); if (!suitKey) { console.error(`renderCard Error: Invalid suit "${card.suit}"`); return '<div class="card error">?</div>'; } const suitClass = suitKey.toLowerCase(); const playableClass = isPlayableCard ? ' playable' : ''; return `<div class="card ${suitClass}${playableClass}" data-card-id="${card.id}"><span class="rank">${card.rank}</span><span class="suit">${card.suit}</span></div>`; }
        function renderHand(playerPos) { const handEl = playerHands[playerPos]; if (!handEl) { console.error(`renderHand Error: El not found for ${playerPos}`); return; } const cards = hands[playerPos]; handEl.innerHTML = ''; if (!cards) { console.warn(`renderHand: No cards array for player at pos ${playerPos}.`); return; } if (cards.length === 0 && gameState !== 'INIT' && gameState !== 'LOBBY') { return; } const isMyHand = playerPos === myPosition; if (!isMyHand && gameState !== 'GAME_OVER') { for (let i = 0; i < cards.length; i++) handEl.innerHTML += renderCard(null, true); } else { const canPlayNow = gameState === 'PLAYING' && currentPlayer === playerPos && isMyHand; let cardsHtml = ''; cards.forEach((card, index) => { try { if (!card || !card.id) { console.error(`renderHand Error: Invalid card at index ${index} for ${playerPos}:`, card); cardsHtml += '<div class="card error">!</div>'; return; } let playable = false; if (canPlayNow && gameState === 'PLAYING' && currentTrick !== undefined) { playable = isPlayable(playerPos, card); } cardsHtml += renderCard(card, false, playable); } catch (e) { console.error(`Error rendering card ${card?.id} for ${playerPos}:`, e); cardsHtml += '<div class="card error">E</div>'; } }); handEl.innerHTML = cardsHtml; if (canPlayNow) { handEl.querySelectorAll('.card.playable').forEach(cardEl => { if (!cardEl.onclick) { cardEl.addEventListener('click', () => { handlePlayCard(myPosition, cardEl.dataset.cardId); }); } }); } } }
        function renderAllHands() { PLAYERS.forEach(playerPos => renderHand(playerPos)); }
        function renderTrickArea() { clearTrickArea(); currentTrick.forEach(play => { const slot = trickCardSlots[play.player]; if (slot) { try { const cardElString = renderCard(play.card); const tempDiv = document.createElement('div'); tempDiv.innerHTML = cardElString.trim(); const cardEl = tempDiv.firstChild; if(cardEl) slot.appendChild(cardEl); else console.error("renderTrickArea: Failed to create card el"); } catch (e) { console.error(`Error rendering trick card for ${play.player}:`, e); } } else { console.error("renderTrickArea Error: No slot for:", play.player); } }); }
        function clearTrickArea() { PLAYERS.forEach(p => { if(trickCardSlots && trickCardSlots[p]) trickCardSlots[p].innerHTML=''; }); }
        function hideBiddingControls() { if(controlsAreaEl) controlsAreaEl.classList.remove('visible'); if(controlsButtonsEl) controlsButtonsEl.innerHTML = ''; }
        function updateCurrentPlayerHighlight() { PLAYERS.forEach(p => playerAreaEls[p]?.classList.toggle('current-player', p===currentPlayer&&(gameState==='BIDDING'||gameState==='PLAYING'))); }
        function clearCurrentPlayerHighlight() { PLAYERS.forEach(p => playerAreaEls[p]?.classList.remove('current-player')); }
        function updateBiddingControls() { hideBiddingControls(); if (gameState !== 'BIDDING') return; if (currentPlayer === myPosition) { controlsAreaEl.classList.add('visible'); controlsButtonsEl.innerHTML = ''; const currentLevel = BIDS.indexOf(currentBid.bid); const passBtn = document.createElement('button'); passBtn.textContent = BID_NAMES['PASS']; passBtn.classList.add('pass'); passBtn.onclick = () => handleBid(myPosition, 'PASS'); controlsButtonsEl.appendChild(passBtn); BIDS.slice(1).forEach((bid) => { const btn = document.createElement('button'); btn.textContent = BID_NAMES[bid]; btn.classList.add('bid'); const bidLevel = BIDS.indexOf(bid); btn.disabled = bidLevel <= currentLevel; btn.onclick = () => handleBid(myPosition, bid); controlsButtonsEl.appendChild(btn); }); } else { setMessage(`Наддаване: Ред на ${getPlayerName(playerNames[currentPlayer] || currentPlayer)}`); } }
        function updatePersistentTrumpInfo() { let htmlContent = ""; if (!persistentTrumpInfoEl) return; if (!trumpSuit || trumpSuit === 'PASS' || gameState === 'BIDDING' || gameState === 'DEALING' || gameState === 'DEALING_FINAL') { htmlContent = currentBid.bid === 'PASS' ? "Наддаване..." : `Последно: ${getPlayerName(playerNames[currentBid.player] || currentBid.player)} - ${BID_NAMES[currentBid.bid]}`; } else if (trumpSuit === 'NO_TRUMP') htmlContent = `<strong>Без Коз</strong><br/>(${getPlayerName(playerNames[currentBid.player] || currentBid.player)})`; else if (trumpSuit === 'ALL_TRUMP') htmlContent = `<strong>Всичко Коз</strong><br/>(${getPlayerName(playerNames[currentBid.player] || currentBid.player)})`; else { const sSym = SUITS[trumpSuit]; const sClass = trumpSuit.toLowerCase(); htmlContent = `<span class="suit ${sClass}">${sSym}</span> (${BID_NAMES[trumpSuit]})<br/>(${getPlayerName(playerNames[currentBid.player] || currentBid.player)})`; } persistentTrumpInfoEl.innerHTML = htmlContent; }
        function updatePlayableCards() { if(myPosition && PLAYERS.includes(myPosition)) renderHand(myPosition); }
        function cardToString(card) { return card ? `${card.rank}${card.suit}` : ''; }
        function updateDeclaredAnnouncementsDisplay() { if (!declaredAnnouncementsListEl) return; declaredAnnouncementsListEl.innerHTML = ''; let hasAnyDeclared = false; PLAYERS.forEach(playerPos => { declaredAnnouncements[playerPos].forEach(ann => { hasAnyDeclared = true; const item = document.createElement('div'); item.classList.add('declared-announcement-item'); let text = `<strong>${getPlayerName(playerNames[playerPos] || playerPos)}:</strong> ${ANNOUNCEMENTS_DEF[ann.type].name}`; if (ann.type.startsWith('SQ')) text += ` (${ann.rank})`; else if (ann.type !== 'BELOT') text += ` до ${ann.rank}${ann.suit}`; if (ANNOUNCEMENTS_DEF[ann.type].points === 0 && ann.type !== 'BELOT') text += " (0т)"; else if (ann.type !== 'BELOT') text += ` (${ann.points}т.)`; else text += ` (${ann.points}т.)`; item.innerHTML = text; declaredAnnouncementsListEl.appendChild(item); }); }); if (!hasAnyDeclared) { declaredAnnouncementsListEl.innerHTML = 'Няма обявени анонси в този рунд.'; } }
        function showAnnouncementModal(announcements) { if (!announcementModal || !modalAnnouncementsList || !modalConfirmBtn) return; console.log("Showing announcement modal for human"); modalAnnouncementsList.innerHTML = ''; announcements.forEach(ann => { const label = document.createElement('label'); const cb = document.createElement('input'); cb.type = 'checkbox'; cb.value = ann.id; cb.id = `ann-check-${ann.id}`; let txt = ANNOUNCEMENTS_DEF[ann.type].name; if (ann.type.startsWith('SQ')) txt += ` (${ann.rank})`; else txt += ` до ${ann.rank}${ann.suit}`; if (ANNOUNCEMENTS_DEF[ann.type].points === 0) txt += " (0т)"; label.appendChild(cb); label.appendChild(document.createTextNode(` ${txt}`)); modalAnnouncementsList.appendChild(label); }); modalConfirmBtn.onclick = confirmHumanAnnouncements; announcementModal.style.display = 'block'; }
        function hideAnnouncementModal() { if(announcementModal) announcementModal.style.display = 'none'; }

        // --- Логика на Играта ---
        function createDeck() { deck = []; for (const sK in SUITS) { const s = SUITS[sK]; for (const r of RANKS) deck.push({ suit: s, rank: r, id: `${r}${s}` }); } }
        function shuffleDeck() { for (let i = deck.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [deck[i], deck[j]] = [deck[j], deck[i]]; } }
        function cutDeck() { if(deck.length<10)return; const mC=Math.floor(deck.length*.25),xC=Math.floor(deck.length*.75); const cP=Math.floor(Math.random()*(xC-mC+1))+mC; console.log(`Deck cut at ${cP}`); deck=deck.slice(cP).concat(deck.slice(0,cP)); }
        function getNextPlayer(p) { if (!p||PLAYERS.indexOf(p)===-1){console.error(`Invalid player "${p}"!`);return PLAYERS[0];} const i=PLAYERS.indexOf(p); return PLAYERS[(i+1)%4]; }
        function getPlayerOrderStartingFrom(sP) { if (!sP||PLAYERS.indexOf(sP)===-1){console.error(`Invalid startPlayer "${sP}"!`);return [...PLAYERS];} const i=PLAYERS.indexOf(sP); return [...PLAYERS.slice(i),...PLAYERS.slice(0,i)]; }
        function dealInitialCards() { console.log("dealInitialCards called. Dealer:", currentDealer, "GameMode:", gameMode); setMessage(`Раздава ${getPlayerName(playerNames[currentDealer] || currentDealer)}...`); gameState='DEALING'; hands={S:[],W:[],N:[],E:[]}; trickHistory=[]; currentTrick=[]; potentialAnnouncements={S:[],W:[],N:[],E:[]}; declaredAnnouncements={S:[],W:[],N:[],E:[]}; playerDeclaredFlags={S:!1,W:!1,N:!1,E:!1}; belotStatus={S:{hasKQ:!1,declared:!1},W:{hasKQ:!1,declared:!1},N:{hasKQ:!1,declared:!1},E:{hasKQ:!1,declared:!1}}; roundScores={NS:{points:0,announcements:0},EW:{points:0,announcements:0}}; trumpSuit=null; currentBid={player:null,bid:'PASS',level:-1}; biddingHistory=[]; clearTrickArea(); updatePersistentTrumpInfo(); hideBiddingControls(); if(declaredAnnouncementsListEl) declaredAnnouncementsListEl.innerHTML='Няма обявени анонси в този рунд.'; if (isHost || gameMode === 'LOCAL') { const nextP=getNextPlayer(currentDealer); let order=getPlayerOrderStartingFrom(nextP); if (!order||typeof order[Symbol.iterator]!=='function'){console.error("FATAL: playerOrder not iterable!", order); setMessage("Крит. грешка!"); return;} for(let i=0;i<3;i++){for(const p of order){if(deck.length>0){const c=deck.pop();if(c)hands[p].push(c);else console.warn("Popped undefined!");}else{console.warn("Deck empty (3)!");break;}}} for(let i=0;i<2;i++){for(const p of order){if(deck.length>0){const c=deck.pop();if(c)hands[p].push(c);else console.warn("Popped undefined!");}else{console.warn("Deck empty (2)!");break;}}} sortHands(); if (gameMode === 'MULTIPLAYER_HOST') { const handsData = {}; PLAYERS.forEach(pos => handsData[pos] = hands[pos]); broadcastToAll({ type: "DEAL_CARDS_PHASE1", hands: handsData, dealer: currentDealer }); } else { renderAllHands(); gameState='BIDDING'; startBidding(); } } }
        function dealFinalCards() { console.log("Dealing final cards..."); if (isHost || gameMode === 'LOCAL') {setMessage('Финално раздаване...'); gameState='DEALING_FINAL'; let order=getPlayerOrderStartingFrom(getNextPlayer(currentDealer)); for(let i=0;i<3;i++){for(const p of order){if(deck.length>0){const c=deck.pop();if(c)hands[p].push(c);else console.warn("Popped undef (final)!");}else{console.warn("Deck empty (final)!");break;}}} sortHands(); detectAllAnnouncements(); const handsData={}; PLAYERS.forEach(pos=>handsData[pos]=hands[pos]); if(gameMode==='MULTIPLAYER_HOST'){broadcastToAll({type:"DEAL_CARDS_PHASE2",hands:handsData,potentialAnnouncements:potentialAnnouncements});} else {renderAllHands(); gameState='PLAYING'; currentPlayer=getNextPlayer(currentDealer); startPlayingPhase();}}}
        function sortHands() { const sO=[SUITS.CLUBS,SUITS.DIAMONDS,SUITS.HEARTS,SUITS.SPADES]; for(const p of PLAYERS){if(!hands[p])continue; hands[p].sort((a,b)=>{if(!a||!b)return 0; const sc=sO.indexOf(a.suit)-sO.indexOf(b.suit); if(sc!==0)return sc; const rvA=getRankValue(a,!1),rvB=getRankValue(b,!1); return rvA-rvB; });} }
        function startBidding() { currentPlayer=getNextPlayer(currentDealer); console.log("Bidding starts. Player:",currentPlayer,"(My pos:",myPosition,")"); setMessage(`Наддаване: Ред на ${getPlayerName(playerNames[currentPlayer]||currentPlayer)}`); persistentTrumpInfoEl.textContent="Наддаване..."; biddingHistory=[]; updateCurrentPlayerHighlight(); updateBiddingControls();}
        function handleBid(playerPos,bid){if(playerPos!==currentPlayer||gameState!=='BIDDING'){console.warn(`Invalid bid by ${playerPos}. Current: ${currentPlayer}`);return;} console.log(`${getPlayerName(playerNames[playerPos]||playerPos)} bids: ${BID_NAMES[bid]}`); if(gameMode==='MULTIPLAYER_GUEST'&&playerPos===myPosition){sendToHost({type:"PLAYER_BID",bid:bid}); hideBiddingControls(); setMessage("Изпратено наддаване. Чакане..."); return;} let validBid=!1; biddingHistory.push({player:playerPos,bid:bid}); const cL=BIDS.indexOf(currentBid.bid),nL=BIDS.indexOf(bid); if(bid==='PASS'){validBid=!0;}else{if(nL>cL){currentBid={player:playerPos,bid:bid,level:nL};validBid=!0;}else{setMessage("Невалидно наддаване.");if(playerPos===myPosition)updateBiddingControls();return;}} if(validBid){if(isHost){broadcastToAll({type:"BID_UPDATE",biddingPlayer:playerPos,bidMade:bid,currentHighestBid:currentBid,biddingHistory:biddingHistory});} if(bid!=='PASS'&& (isHost || gameMode === 'LOCAL')) updatePersistentTrumpInfo(); if(checkBiddingEnd()){if(isHost)broadcastToAll({type:"BIDDING_END",finalBid:currentBid}); finalizeBidding();}else{moveToNextBidder();}}}
        function moveToNextBidder(){currentPlayer=getNextPlayer(currentPlayer);console.log("Next bidder:",currentPlayer);if(isHost){broadcastToAll({type:"NEXT_BIDDER",nextPlayer:currentPlayer});} setMessage(`Наддаване: Ред на ${getPlayerName(playerNames[currentPlayer]||currentPlayer)}`);updateCurrentPlayerHighlight();updateBiddingControls();}
        function checkBiddingEnd() { if(biddingHistory.length<4)return!1; const l4=biddingHistory.slice(-4); if(l4.every(b=>b.bid==='PASS')){if(biddingHistory.length===4||(biddingHistory[biddingHistory.length-5]?.bid==='PASS'))return!0;} if(currentBid.bid!=='PASS'&&biddingHistory.length>=3){return biddingHistory.slice(-3).every(b=>b.bid==='PASS');} return!1;}
        function finalizeBidding() {hideBiddingControls();clearCurrentPlayerHighlight();if(currentBid.bid==='PASS'){setMessage("Всички пасуваха! Прераздаване...");gameState='INIT';if(isHost||gameMode==='LOCAL')setTimeout(startGame,2500);}else{trumpSuit=currentBid.bid;setMessage(`${getPlayerName(playerNames[currentBid.player]||currentBid.player)} спечели с ${BID_NAMES[trumpSuit]}! Финално раздаване...`);updatePersistentTrumpInfo();if(isHost||gameMode==='LOCAL')setTimeout(dealFinalCards,1500);}}
        function detectAllAnnouncements() { potentialAnnouncements={S:[],W:[],N:[],E:[]}; belotStatus={S:{hasKQ:!1,declared:!1},W:{hasKQ:!1,declared:!1},N:{hasKQ:!1,declared:!1},E:{hasKQ:!1,declared:!1}}; PLAYERS.forEach(p=>{const h=hands[p]; if(!h) return; const seq=findSequences(h); const kar=findKares(h,trumpSuit); let pot= [...seq,...kar]; if(trumpSuit&&trumpSuit!=='NO_TRUMP'&&trumpSuit!=='PASS'){const bel=findBelot(h); if(bel){pot.push(bel);belotStatus[p].hasKQ=!0;}else{belotStatus[p].hasKQ=!1;}}else{belotStatus[p].hasKQ=!1;} potentialAnnouncements[p]=pot;}); console.log("Potential Anns:", potentialAnnouncements); }
        function findSequences(h) { let seqs=[]; const byS={}; SUIT_KEYS.forEach(k=>byS[SUITS[k]]=[]); h.forEach(c=>byS[c.suit].push(c)); for(const s of Object.values(SUITS)){const sC=byS[s]; if(sC.length<3)continue; sC.sort((a,b)=>RANK_ORDER_FOR_SEQ.indexOf(a.rank)-RANK_ORDER_FOR_SEQ.indexOf(b.rank)); let cur=[sC[0]]; for(let i=1;i<sC.length;i++){if(!cur||cur.length===0){cur=[sC[i]];continue;}if(!sC[i])continue; const cRI=RANK_ORDER_FOR_SEQ.indexOf(sC[i].rank); const pRI=RANK_ORDER_FOR_SEQ.indexOf(cur[cur.length-1].rank); if(cRI===pRI+1){cur.push(sC[i]);}else{if(cur.length>=3)seqs.push(createAnnouncementObject(cur)); cur=[sC[i]];}} if(cur&&cur.length>=3)seqs.push(createAnnouncementObject(cur));} let filt=[]; seqs.sort((a,b)=>{if(!a||!b)return 0; return b.value-a.value;}); for(const s of seqs){if(!s)continue; let isSub=!1; for(const ex of filt){if(!ex)continue; if(s.suit===ex.suit&&s.cards.every(sC=>ex.cards.some(eC=>eC.id===sC.id))){isSub=!0;break;}} if(!isSub)filt.push(s);} return filt;}
        function createAnnouncementObject(sC) { if(!sC||sC.length<3)return null; const len=sC.length; const hC=sC[len-1]; if(!hC)return null; let t=''; if(len>=5)t='QUINTA'; else if(len===4)t='QUARTA'; else if(len===3)t='TERCA'; else return null; const d=ANNOUNCEMENTS_DEF[t]; const rV=RANK_ORDER_FOR_SEQ.indexOf(hC.rank); return {type:t,rank:hC.rank,suit:hC.suit,value:d.value,points:d.points,rankValue:rV,id:`${t}-${hC.rank}-${hC.suit}`,cards:sC};}
        function findBelot(h) { if(!trumpSuit||trumpSuit==='NO_TRUMP'||trumpSuit==='PASS')return null; const tS=SUITS[trumpSuit]; const hK=h.some(c=>c.suit===tS&&c.rank==='K'); const hQ=h.some(c=>c.suit===tS&&c.rank==='Q'); if(hK&&hQ){const d=ANNOUNCEMENTS_DEF['BELOT']; return {type:'BELOT',suit:tS,value:d.value,points:d.points,id:`BELOT-${tS}`,cards:h.filter(c=>c.suit===tS&&(c.rank==='K'||c.rank==='Q'))};} return null; }
        function findKares(h,cT) { let k=[]; const byR={}; RANKS.forEach(r=>byR[r]=[]); h.forEach(c=>byR[c.rank].push(c)); for(const r of RANKS){if(byR[r].length===4){let oT=`SQ_${r}`; let kT=oT; let kD=ANNOUNCEMENTS_DEF[kT]; if(cT==='NO_TRUMP'){if(r==='A'&&ANNOUNCEMENTS_DEF['SQ_A_NT']){kT='SQ_A_NT';kD=ANNOUNCEMENTS_DEF[kT];}else if(r==='10'&&ANNOUNCEMENTS_DEF['SQ_10_NT']){kT='SQ_10_NT';kD=ANNOUNCEMENTS_DEF[kT];}} if(kD){k.push({type:kT,rank:r,value:kD.value,points:kD.points,rankValue:kD.rankValue,id:`${kT}`,cards:byR[r]});}}} return k;}
        function compareAnnouncements(a1,a2){if(!a1)return-1;if(!a2)return 1;if(a1.value!==a2.value)return a1.value-a2.value;if(a1.rankValue!==a2.rankValue)return a1.rankValue-a2.rankValue;return 0;}
        function startPlayingPhase() { console.log("Playing phase. Player:",currentPlayer," MyPos:", myPosition);setMessage(`Игра: ${BID_NAMES[trumpSuit]||'Грешка'}. Ред на ${getPlayerName(playerNames[currentPlayer]||currentPlayer)}.`); clearTrickArea(); currentTrick=[]; updateCurrentPlayerHighlight(); preparePlayerTurn();}
        function preparePlayerTurn(){console.log(`preparePlayerTurn ${currentPlayer}. MyPos: ${myPosition}. Trick#: ${trickHistory.length}, Declared: ${playerDeclaredFlags[currentPlayer]}`);if(trickHistory.length===0&&currentPlayer===myPosition&&!playerDeclaredFlags[myPosition]){handleFirstTurnAnnouncement(myPosition);}else{allowCardPlay(myPosition);}}
        function handleFirstTurnAnnouncement(playerPos){console.log(`Handling 1st turn ann for ${playerPos}. Trump: ${trumpSuit}`); let allowedAnns=[]; const isNTG=trumpSuit==='NO_TRUMP'; if(isNTG){allowedAnns=potentialAnnouncements[playerPos]?.filter(a=>a&&(a.type==='SQ_A_NT'||a.type==='SQ_10_NT'))||[];}else{allowedAnns=potentialAnnouncements[playerPos]?.filter(a=>a&&a.type!=='BELOT'&&(ANNOUNCEMENTS_DEF[a.type]?.points>0||['SQ_7','SQ_8','SQ_9'].includes(a.type)))||[];} if(playerPos===myPosition){if(allowedAnns.length>0){showAnnouncementModal(allowedAnns);}else{setMessage("Няма анонси. Играй."); playerDeclaredFlags[playerPos]=!0; allowCardPlay(playerPos);}}else{ /* Гостите не показват модал, хостът ще получи анонсите им */ playerDeclaredFlags[playerPos]=!0; allowCardPlay(playerPos);}}
        function confirmHumanAnnouncements(){console.log("Human confirmed anns"); let declaredByMe=[]; const cbs=modalAnnouncementsList.querySelectorAll('input[type="checkbox"]:checked'); cbs.forEach(cb=>{const ann=potentialAnnouncements[myPosition].find(a=>a.id===cb.value); if(ann)declaredByMe.push(ann);}); playerDeclaredFlags[myPosition]=!0; hideAnnouncementModal(); if(gameMode.startsWith("MULTIPLAYER")){sendToHostOrBroadcast({type:"PLAYER_ANNOUNCEMENTS",announcements:declaredByMe,playerPos:myPosition});}else{declaredAnnouncements[myPosition]=declaredByMe;updateDeclaredAnnouncementsDisplay();} setMessage("Изберете карта.");allowCardPlay(myPosition);}
        function allowCardPlay(playerPos){if(playerPos===myPosition){console.log(`Allowing card play for ME (${myPosition})`);updatePlayableCards();}else{console.log(`Not my turn (${currentPlayer}) or not my pos (${myPosition}) to play.`);}}
        function handlePlayCard(playerPos_ShouldBeMyPosition, cardId) {
            console.log(`handlePlayCard CLICK for myPos: ${myPosition}, cardId: ${cardId}. CurrentPlayer: ${currentPlayer}`);

            if (myPosition !== currentPlayer || gameState !== 'PLAYING') {
                console.warn("handlePlayCard: Not my turn or not playing state.");
                return;
            }
            if (trickHistory.length === 0 && !playerDeclaredFlags[myPosition]) {
                setMessage("Моля, първо потвърдете анонсите си.");
                if (announcementModal && announcementModal.style.display === 'block') { return; }
            }

            const cardToPlay = hands[myPosition]?.find(c => c.id === cardId);
            if (!cardToPlay) { console.error("handlePlayCard: Card not found in my hand!"); return; }
            if (!isPlayable(myPosition, cardToPlay)) { setMessage("Невалиден ход!"); console.warn("handlePlayCard: Card is not playable."); return; }

            if (gameMode.startsWith("MULTIPLAYER")) {
                if (isHost) { // Аз съм ХОСТ и играя карта
                    console.log("Host initiating card play for self:", cardToPlay.id);
                    processPlayedCard(myPosition, cardId); // Хостът обработва своя ход и изпраща
                } else { // Аз съм ГОСТ и играя карта
                    console.log("Guest playing card, sending to host:", cardToPlay.id);
                    sendToHost({ type: "PLAY_CARD", cardId: cardId, playerPos: myPosition });
                    hideBiddingControls();
                    setMessage("Изпратена карта. Чакане...");
                }
            } else { // ЛОКАЛНА ИГРА
                console.log("Local game, playing card:", cardToPlay.id);
                processPlayedCard(myPosition, cardId); // Локалната игра се обработва директно
            }
        }
        function checkAndDeclareBelot(playerPos, playedCard) {
            if (trumpSuit && trumpSuit !== 'NO_TRUMP' && trumpSuit !== 'PASS' &&
                belotStatus[playerPos].hasKQ && !belotStatus[playerPos].declared) {
                const trumpSuitSymbol = SUITS[trumpSuit];
                if (playedCard.suit === trumpSuitSymbol && (playedCard.rank === 'K' || playedCard.rank === 'Q')) {
                    const belotAnn = potentialAnnouncements[playerPos]?.find(a => a.type === 'BELOT');
                    if (belotAnn) {
                        let declareBelot = false;
                        if (playerPos === myPosition) { // Ако е мой ред (и съм човек)
                            declareBelot = confirm(`Имате Белот (${playedCard.rank}${playedCard.suit})! Искате ли да го обявите?`);
                        } else if (gameMode === 'LOCAL' || isHost) { // AI или ход на гост, обработван от хост
                            declareBelot = true; // AI/Гостите (чрез хоста) обявяват автоматично
                        }

                        if (declareBelot) {
                            belotStatus[playerPos].declared = true;
                            const belotMessage = `${getPlayerName(playerNames[playerPos] || playerPos)} обявява БЕЛОТ!`;
                            setMessage(belotMessage); // Показва съобщението локално

                            if (!declaredAnnouncements[playerPos].some(a => a.type === 'BELOT')) {
                                declaredAnnouncements[playerPos].push(belotAnn);
                            }
                            updateDeclaredAnnouncementsDisplay(); // Обновява списъка с обявени

                            // Ако сме хост и гост е обявил белот (или ние сме обявили), изпращаме ъпдейт
                            if (isHost) {
                                broadcastToAll({
                                    type: "ANNOUNCEMENT_DECLARED",
                                    playerPos: playerPos,
                                    announcements: declaredAnnouncements[playerPos], // Изпращаме всички анонси на този играч
                                    belotDeclaredMessage: belotMessage // Изпращаме и съобщението за белот
                                });
                            }
                        }
                    }
                }
            }
        }
                // --- Корекция в processPlayedCard (изпълнява се САМО от хоста или в локална игра) ---
        function processPlayedCard(playerPos, cardId) {
            console.log(`processPlayedCard for player: ${playerPos}, card: ${cardId}`);
            if (playerPos !== currentPlayer || gameState !== 'PLAYING') {
                console.warn("processPlayedCard: Not current player or not playing state.");
                return;
            }

            const cardToPlay = hands[playerPos]?.find(c => c.id === cardId);
            if (!cardToPlay) {
                console.error("processPlayedCard: Card not found!");
                return;
            }

            // 1. Актуализиране на локалното състояние (за хоста или локална игра)
            hands[playerPos] = hands[playerPos].filter(c => c.id !== cardId);
            currentTrick.push({ player: playerPos, card: cardToPlay });

            // 2. Проверка за Белот
            let belotInfo = null;
            // ... (логиката за belotInfo остава същата) ...
            if (trumpSuit && trumpSuit !== 'NO_TRUMP' && trumpSuit !== 'PASS' &&
                belotStatus[playerPos].hasKQ && !belotStatus[playerPos].declared) {
                const trumpSuitSymbol = SUITS[trumpSuit];
                if (cardToPlay.suit === trumpSuitSymbol && (cardToPlay.rank === 'K' || cardToPlay.rank === 'Q')) {
                    const belotAnn = potentialAnnouncements[playerPos]?.find(a => a.type === 'BELOT');
                    if (belotAnn) {
                        let declareBelot = true; // Приемаме, че се обявява, ако е възможно
                        if (playerPos === myPosition && (isHost || gameMode === 'LOCAL')) { // Само ако аз съм този играч (и съм хост/локално)
                           // declareBelot = confirm(`Имате Белот (${cardToPlay.rank}${cardToPlay.suit})! Искате ли да го обявите?`);
                           // За улеснение на тестването, нека винаги да се обявява, ако е налично
                        }

                        if (declareBelot) {
                            belotStatus[playerPos].declared = true;
                            const belotMessage = `${getPlayerName(playerNames[playerPos] || playerPos)} обявява БЕЛОТ!`;
                            if (!declaredAnnouncements[playerPos].some(a => a.type === 'BELOT')) {
                                declaredAnnouncements[playerPos].push(belotAnn);
                            }
                            belotInfo = { playerPos: playerPos, message: belotMessage, announcements: declaredAnnouncements[playerPos] };
                        }
                    }
                }
            }


            // 3. Ако е хост, изпраща актуализацията
            if (isHost) {
                broadcastToAll({ // Изпраща на всички, включително на себе си
                    type: "CARD_PLAYED",
                    playerPos: playerPos,
                    card: cardToPlay,
                    currentTrick: currentTrick,
                    belotInfo: belotInfo
                });
                // След като е изпратено, хостът веднага преминава към следващия ход или край на взятка
                // moveToNextPlayerInTrick(); // ТОВА СЕ ИЗВИКВА ВЕДНАГА СЛЕД BROADCAST
            } else if (gameMode === 'LOCAL') {
                // Локална игра: ръчно рендиране и преминаване
                renderHand(playerPos);
                renderTrickArea();
                if (belotInfo) {
                    updateDeclaredAnnouncementsDisplay();
                    setMessage(belotInfo.message);
                }
                moveToNextPlayerInTrick();
            }
            // Гостите не правят нищо тук, те чакат CARD_PLAYED от хоста.
            // След като хостът изпрати CARD_PLAYED, той ще извика moveToNextPlayerInTrick,
            // което пък ще изпрати NEXT_PLAYER_TRICK или TRICK_RESULT.
        }
        function determineTrickWinner(){gameState='SCORING_TRICK';clearCurrentPlayerHighlight();setMessage('Изчисляване...');let winP=findCurrentTrickWinner();if(!winP){console.error("No trick winner!");winP=currentTrick[0];} const win=winP.player;let pts=0;currentTrick.forEach(pl=>pts+=getCardPoints(pl.card));const last=(hands.S?.length===0&&hands.W?.length===0&&hands.N?.length===0&&hands.E?.length===0);if(last)pts+=10;const winT=(win=='N'||win=='S')?'NS':'EW';roundScores[winT].points+=pts;if(isHost||gameMode==='LOCAL'){broadcastToAll({type:"TRICK_RESULT",winner:win,winningCard:winP.card,points:pts,isLastTrick:last,roundScores:roundScores});} setMessage(`${getPlayerName(playerNames[win]||win)} печели с ${cardToString(winP.card)}. Точки: ${pts}${last?' (+10)':''}`);trickHistory.push({winner:win,trick:[...currentTrick],points:pts});setTimeout(()=>{clearTrickArea();if(last){if(isHost||gameMode==='LOCAL')endRound();}else{currentPlayer=win;gameState='PLAYING';startPlayingPhase();}},1800);}
        function endRound() {
            gameState = 'END_ROUND';
            let initialMessage = 'Край на рунда. Изчисляване...';

            const isNoTrumpGame = trumpSuit === 'NO_TRUMP';
            const isAllTrumpGame = trumpSuit === 'ALL_TRUMP';
            const multiplier = isNoTrumpGame ? 2 : 1;

            // --- 1. Точкуване на Анонси ---
            let highestAnnNS = null; let highestAnnEW = null;
            let belotPointsNS = 0; let belotPointsEW = 0;
            let regularAnnPointsNS_Raw = 0; let regularAnnPointsEW_Raw = 0;

             ['N', 'S'].forEach(p => {
                 declaredAnnouncements[p].forEach(ann => {
                     if (ann.type === 'BELOT') { belotPointsNS = Math.max(belotPointsNS, ann.points); }
                     else { regularAnnPointsNS_Raw += ann.points; if (compareAnnouncements(ann, highestAnnNS) > 0) { highestAnnNS = ann; } }
                 });
             });
             ['E', 'W'].forEach(p => {
                  declaredAnnouncements[p].forEach(ann => {
                      if (ann.type === 'BELOT') { belotPointsEW = Math.max(belotPointsEW, ann.points); }
                      else { regularAnnPointsEW_Raw += ann.points; if (compareAnnouncements(ann, highestAnnEW) > 0) { highestAnnEW = ann; } }
                  });
             });

            let nsGetsRegularAnns = false;
            let ewGetsRegularAnns = false;
            const comparisonResult = compareAnnouncements(highestAnnNS, highestAnnEW);
            if (comparisonResult > 0) { nsGetsRegularAnns = true; initialMessage = `Ние печелим анонсите (${highestAnnNS.name}).`; }
            else if (comparisonResult < 0) { ewGetsRegularAnns = true; initialMessage = `Те печелят анонсите (${highestAnnEW.name}).`; }
            else if (highestAnnNS) { initialMessage = "Равни анонси - без точки (освен Белот)."; }
            else { initialMessage = "Няма редовни анонси."; }

            const finalAnnPointsNS = belotPointsNS + (nsGetsRegularAnns ? regularAnnPointsNS_Raw : 0);
            const finalAnnPointsEW = belotPointsEW + (ewGetsRegularAnns ? regularAnnPointsEW_Raw : 0);

            // --- 2. Проверка за Капо ---
            let isCapot = false;
            let capotTeam = null;
            if (trickHistory.length === 8) {
                 if (trickHistory.every(t => t.winner === 'N' || t.winner === 'S')) { isCapot = true; capotTeam = 'NS'; }
                 else if (trickHistory.every(t => t.winner === 'E' || t.winner === 'W')) { isCapot = true; capotTeam = 'EW'; }
            }

            // --- 3. Изчисляване на финалните точки за рунда ---
            const biddingTeam = (currentBid.player === 'N' || currentBid.player === 'S') ? 'NS' : 'EW';
            let nsRoundScore = 0; // Инициализация тук, за да е винаги дефинирана
            let ewRoundScore = 0; // Инициализация тук, за да е винаги дефинирана
            const trickPointsNS_Raw = roundScores['NS'].points;
            const trickPointsEW_Raw = roundScores['EW'].points;

            if (isCapot) {
                // --- Логика при Капо ---
                const winnerTeam = capotTeam;
                const loserTeam = (winnerTeam === 'NS') ? 'EW' : 'NS';
                const loserWasBidding = loserTeam === biddingTeam;
                let penalty = -10;
                if (loserWasBidding) { penalty = -20; }

                initialMessage += ` КАПО за ${winnerTeam === 'NS' ? 'Нас' : 'Тях'}!`;
                if (loserWasBidding) initialMessage += ` (${loserTeam === 'NS' ? 'Ние' : 'Те'} сме и Вътре!)`;

                if (winnerTeam === 'NS') { nsRoundScore = 9 + Math.round((finalAnnPointsNS * multiplier) / 10); }
                else { ewRoundScore = 9 + Math.round((finalAnnPointsEW * multiplier) / 10); }
                if (loserTeam === 'NS') { nsRoundScore = (penalty * multiplier) + Math.round((finalAnnPointsNS * multiplier) / 10); }
                else { ewRoundScore = (penalty * multiplier) + Math.round((finalAnnPointsEW * multiplier) / 10); }

            } else {
                // --- Нормална игра (без капо) ---

                // --- Сравнение за Вътре/Вън ---
                const pointsForCompareNS = trickPointsNS_Raw + (nsGetsRegularAnns ? regularAnnPointsNS_Raw : 0);
                const pointsForCompareEW = trickPointsEW_Raw + (ewGetsRegularAnns ? regularAnnPointsEW_Raw : 0);
                const biddingTeamCompareTotal = (biddingTeam === 'NS') ? pointsForCompareNS : pointsForCompareEW;
                const defendingTeamCompareTotal = (biddingTeam === 'NS') ? pointsForCompareEW : pointsForCompareNS;
                const isInside = biddingTeamCompareTotal < defendingTeamCompareTotal;

                // --- Закръгляне САМО на точките от взятки ---
                 let roundedNS, roundedEW;
                 if (isNoTrumpGame) { /* ... Логика за закръгляне на 5 ... */
                    roundedNS = Math.round(trickPointsNS_Raw / 5) * 5;
                    roundedEW = Math.round(trickPointsEW_Raw / 5) * 5;
                    const totalRaw = trickPointsNS_Raw + trickPointsEW_Raw;
                    const targetTotal = totalRaw >= 135 ? 140 : 130;
                    if (roundedNS + roundedEW !== targetTotal) { /* Логика за корекция */
                        if (roundedNS + roundedEW > targetTotal) { if (roundedNS > trickPointsNS_Raw && roundedNS >= roundedEW) roundedNS -= 5; else if (roundedEW > trickPointsEW_Raw) roundedEW -= 5; else if(roundedNS >= roundedEW) roundedNS -=5; else roundedEW -=5;}
                        else { if (roundedEW < trickPointsEW_Raw && roundedEW <= roundedNS) roundedEW += 5; else if (roundedNS < trickPointsNS_Raw) roundedNS += 5; else if(roundedEW <= roundedNS) roundedEW +=5; else roundedNS +=5;}
                        if (roundedNS + roundedEW !== targetTotal) console.warn(`NT Rounding Adjust failed: ${roundedNS}+${roundedEW} != ${targetTotal}`);
                    }
                 } else if (isAllTrumpGame) { /* ... Логика за закръгляне при Всичко Коз (проблем на 4) ... */
                     if (trickPointsNS_Raw % 10 === 4) { if (trickPointsNS_Raw <= trickPointsEW_Raw) { roundedNS = Math.ceil(trickPointsNS_Raw / 10) * 10; roundedEW = Math.floor(trickPointsEW_Raw / 10) * 10; } else { roundedEW = Math.ceil(trickPointsEW_Raw / 10) * 10; roundedNS = Math.floor(trickPointsNS_Raw / 10) * 10; } }
                     else { roundedNS = Math.round(trickPointsNS_Raw / 10) * 10; roundedEW = Math.round(trickPointsEW_Raw / 10) * 10; if(roundedNS+roundedEW==250){if(trickPointsNS_Raw%10>trickPointsEW_Raw%10)roundedNS+=10;else roundedEW+=10;} else if(roundedNS+roundedEW==270){if(trickPointsNS_Raw%10<trickPointsEW_Raw%10)roundedNS-=10;else roundedEW-=10;} }
                 } else { /* ... Логика за закръгляне при Коз (проблем на 6) ... */
                     if (trickPointsNS_Raw % 10 === 6) { if (trickPointsNS_Raw <= trickPointsEW_Raw) { roundedNS = Math.ceil(trickPointsNS_Raw / 10) * 10; roundedEW = Math.floor(trickPointsEW_Raw / 10) * 10; } else { roundedEW = Math.ceil(trickPointsEW_Raw / 10) * 10; roundedNS = Math.floor(trickPointsNS_Raw / 10) * 10; } }
                     else { roundedNS = Math.round(trickPointsNS_Raw / 10) * 10; roundedEW = Math.round(trickPointsEW_Raw / 10) * 10; if(roundedNS+roundedEW==150){if(trickPointsNS_Raw%10>trickPointsEW_Raw%10)roundedNS+=10;else roundedEW+=10;} else if(roundedNS+roundedEW==170){if(trickPointsNS_Raw%10<trickPointsEW_Raw%10)roundedNS-=10;else roundedEW-=10;} }
                 }
                 console.log(`Raw trick pts: ${trickPointsNS_Raw}-${trickPointsEW_Raw} -> Rounded: ${roundedNS}-${roundedEW}`);

                // --- Изчисляване на финалния резултат за рунда ---
                if (!isInside) {
                    // --- УСПЕШЕН ДОГОВОР ---
                    initialMessage += ` Успешен договор ${BID_NAMES[trumpSuit]}!`;
                    nsRoundScore = Math.round(((roundedNS + finalAnnPointsNS) * multiplier) / 10);
                    ewRoundScore = Math.round(((roundedEW + finalAnnPointsEW) * multiplier) / 10);
                } else {
                    // --- ВЪТРЕ! ---
                    initialMessage += ` ${biddingTeam === 'NS' ? 'Ние' : 'Те'} сме вътре!`;
                    const penalty = -10 * multiplier; // Наказание за "вътре"

                    if (biddingTeam === 'NS') { // Ние сме Вътре
                         nsRoundScore = penalty + Math.round((finalAnnPointsNS * multiplier) / 10);
                         ewRoundScore = Math.round(((roundedNS + roundedEW + finalAnnPointsEW) * multiplier) / 10); // Те взимат общите ЗАКРЪГЛЕНИ + техните анонси
                    } else { // Те са Вътре
                         ewRoundScore = penalty + Math.round((finalAnnPointsEW * multiplier) / 10);
                         nsRoundScore = Math.round(((roundedNS + roundedEW + finalAnnPointsNS) * multiplier) / 10); // Ние взимаме общите ЗАКРЪГЛЕНИ + нашите анонси
                    }
                }
            } // Край на else (не е капо)

             teamScores['NS'] += nsRoundScore;
             teamScores['EW'] += ewRoundScore;

             updateScoreBoard();
             setMessage(`${initialMessage} | Рез. рунд${isNoTrumpGame ? ' (x2)' : ''}: Ние ${nsRoundScore}, Те ${ewRoundScore}. | Общ: ${teamScores['NS']}-${teamScores['EW']}`);

            // --- Проверка за край на играта (151) ---
             if (teamScores['NS'] >= 151 || teamScores['EW'] >= 151) {
                 gameState = 'GAME_OVER';
                 let winner = "";
                 if (teamScores['NS'] >= 151 && teamScores['EW'] < 151) winner = "Ние (Север/Юг)";
                 else if (teamScores['EW'] >= 151 && teamScores['NS'] < 151) winner = "Те (Изток/Запад)";
                 else if (teamScores['NS'] > teamScores['EW']) winner = "Ние (Север/Юг)";
                 else if (teamScores['EW'] > teamScores['NS']) winner = "Те (Изток/Запад)";
                 else winner = "Равенство!";

                 const roundSummary = messagesEl.textContent.split('|')[0].trim();
                 setMessage(`${roundSummary} | КРАЙ НА ИГРАТА! ${winner} печелят с ${teamScores['NS']} на ${teamScores['EW']}!`);
                 if(startGameBtn) startGameBtn.disabled = false;

             } else {
                 currentDealer = getNextPlayer(currentDealer);
                 setTimeout(startGame, 4000);
             }
         } // Край на endRound
        // function getAiBid(h) { /* ПРЕМАХНАТА */ }
        // function triggerAIPlay() { /* ПРЕМАХНАТА */ }
        function wouldWinTrick(cT,cTP,p) { if(cTP.length===0)return!0; const hypo=[...cTP,{player:p,card:cT}]; let winP=findCurrentTrickWinnerHypothetical(hypo); return winP && winP.player===p; }
        function getPartner(p) { const i=PLAYERS.indexOf(p); return PLAYERS[(i+2)%4]; }
        function getPlayerName(nameOrPos) { if (playerNames && playerNames[nameOrPos]) return playerNames[nameOrPos]; if (typeof nameOrPos === 'string' && Object.values(playerNames).includes(nameOrPos)) return nameOrPos; return {S:'Юг',W:'Запад',N:'Север',E:'Изток'}[nameOrPos]||nameOrPos||'X'; }
        function isTrump(c) { if(!c) return false; if(!trumpSuit||trumpSuit=='PASS')return!1; if(trumpSuit=='ALL_TRUMP')return!0; if(trumpSuit=='NO_TRUMP')return!1; const tS=SUITS[trumpSuit]; return c.suit===tS; }
        function getRankValue(c,isT) { const oNT=['7','8','9','J','Q','K','10','A']; const oT=['7','8','Q','K','10','A','9','J']; if(!c || !c.rank) { console.error("Invalid card in getRankValue:", c); return -1;} if (isT || trumpSuit === 'ALL_TRUMP') return oT.indexOf(c.rank); else return oNT.indexOf(c.rank); }
        function getCardPoints(c) { let iT=isTrump(c); if(!c || !c.rank) { console.error("Invalid card in getCardPoints:", c); return 0; } if(trumpSuit=='NO_TRUMP')return POINTS_NO_TRUMP[c.rank]; if(trumpSuit=='ALL_TRUMP')return POINTS_TRUMP[c.rank]; return iT?POINTS_TRUMP[c.rank]:POINTS_NO_TRUMP[c.rank]; }
        function isPlayable(player, card) {
            if (gameState !== 'PLAYING' || player !== currentPlayer) return false;
            if (!card) { console.error("isPlayable called with invalid card!"); return false; }
            if (currentTrick.length === 0) return true;

            const leadCard = currentTrick[0].card;
            if (!leadCard) { console.error("isPlayable: No lead card!"); return false; }
            const leadSuit = leadCard.suit;
            const playerHand = hands[player];
            if (!playerHand) { console.error(`isPlayable: No hand for ${player}!`); return false; }

            const isAllTrumpGame = trumpSuit === 'ALL_TRUMP';
            const hasLeadSuit = playerHand.some(c => c && c.suit === leadSuit);

            if (hasLeadSuit) {
                // ---- ТРЯБВА ДА СЛЕДВА БОЯТА ----
                if (card.suit !== leadSuit) return false;

                // ---- Трябва ли да качи (с карта от ИСКАНАТА боя)? ----
                const currentWinningPlay = findCurrentTrickWinner();
                if (currentWinningPlay && currentWinningPlay.card) {
                    const winningCard = currentWinningPlay.card;
                    const useTrumpRankingForWinComp = isAllTrumpGame || isTrump(winningCard);
                    const winningValue = getRankValue(winningCard, useTrumpRankingForWinComp);
                    const cardIsEffectivelyTrump = isAllTrumpGame || isTrump(card);
                    const cardValue = getRankValue(card, cardIsEffectivelyTrump);

                    // При AllTrump и стандартна игра, АКО ВОДЕЩАТА Е КОЗ -> трябва да се качи
                    if (isAllTrumpGame || isTrump(leadCard)) {
                        const hasHigherInLeadSuit = playerHand.some(c =>
                            c && c.suit === leadSuit &&
                            getRankValue(c, isAllTrumpGame || isTrump(c)) > winningValue
                        );
                        if (hasHigherInLeadSuit && cardValue <= winningValue) {
                            return false; // Трябва да играе по-висока
                        }
                    }
                    // Ако не е AllTrump и водещата НЕ Е коз, не трябва да се качва
                }
                return true; // Валиден ход от боята

            } else {
                // ---- НЯМА ОТ ИСКАНАТА БОЯ ----
                const currentWinningPlay = findCurrentTrickWinner();
                const partner = getPartner(player);

                // *** Проверка за Печеливш Партньор ***
                if (currentWinningPlay && currentWinningPlay.player === partner) {
                    if (!isAllTrumpGame) {
                        const hasAnyTrump = playerHand.some(c => c && isTrump(c));
                        if (hasAnyTrump && (!card || !isTrump(card))) {
                             return false; // Все още трябва да играеш коз, ако имаш
                        }
                    }
                    return true; // Валидно е да не се качва
                }

                // ---- Партньорът НЕ печели ИЛИ няма текущ победител ----

                // *** НОВА ЛОГИКА ЗА ALL TRUMP - OFF SUIT (User Rule) ***
                if (isAllTrumpGame) {
                     // Ако е Всичко Коз и нямаш от боята, НЕ МОЖЕШ да спечелиш
                     // и правилото за качване НЕ ВАЖИ. Можеш да играеш ВСЯКА карта.
                     console.log(`isPlayable OK [AllTrump/NoFollow/UserRule]: Playing any card ${card.id} allowed.`);      
                     return true;
                } else {
                    // ---- СТАНДАРТНА ИГРА С КОЗ (НЯМАШ от боята) ----
                    const hasAnyTrump = playerHand.some(c => c && isTrump(c));
                    if (hasAnyTrump) {
                        if (!card || !isTrump(card)) return false; // Трябва да играе коз

                        // Трябва ли да качи коза?
                        if (currentWinningPlay && currentWinningPlay.card && isTrump(currentWinningPlay.card)) {
                            const winningValue = getRankValue(currentWinningPlay.card, true);
                            const hasHigherTrump = playerHand.some(c =>
                                c && isTrump(c) && getRankValue(c, true) > winningValue
                            );
                            if (hasHigherTrump && getRankValue(card, true) <= winningValue) {
                                return false;
                            }
                        }
                        return true; // Валиден коз
                    } else {
                        return true; // Няма коз, играе всичко
                    }
                }
            }
       } // Край на isPlayable
        function findCurrentTrickWinner() { return findCurrentTrickWinnerHypothetical(currentTrick); }
        function findCurrentTrickWinnerHypothetical(tP) {
            if (!tP || tP.length === 0) return null;
            let winningPlay = tP[0];
            if (!winningPlay || !winningPlay.card) { console.error("Invalid first play in trick", tP); return null;}
            let trickSuit = winningPlay.card.suit; // Водещата боя ЗАПОМНЯМЕ!

            const isAllTrumpGame = trumpSuit === 'ALL_TRUMP';

            for (let i = 1; i < tP.length; i++) {
                const currentPlay = tP[i];
                const winningCard = winningPlay.card;
                const currentCard = currentPlay.card;
                if (!winningCard || !currentCard) { console.error("Invalid card in hypothetical trick:", tP); continue; }

                if (isAllTrumpGame) {
                    // ---- ЛОГИКА ЗА ALL TRUMP (по user rule) ----
                    // Само карта от ВОДЕЩАТА боя (trickSuit) може да спечели.
                    if (currentCard.suit === trickSuit) {
                        // Ако и двете са от водещата боя, сравняваме по козов ранг
                        if (winningCard.suit === trickSuit) {
                             // Сравняваме силата винаги като коз при AllTrump
                             if (getRankValue(currentCard, true) > getRankValue(winningCard, true)) {
                                winningPlay = currentPlay;
                             }
                        } else {
                            // Ако текущата е от водещата, а печелившата досега НЕ Е, текущата печели
                            winningPlay = currentPlay;
                        }
                    }
                    // Ако currentCard НЕ Е от водещата боя, тя НЕ МОЖЕ да спечели.

                } else {
                    // ---- Стандартна логика за игра с коз или без коз ----
                    const wIT = isTrump(winningCard);
                    const cIT = isTrump(currentCard);
                    const wRV = getRankValue(winningCard, wIT);
                    const cRV = getRankValue(currentCard, cIT);

                    if (cIT && !wIT) winningPlay = currentPlay;
                    else if (cIT && wIT && cRV > wRV) winningPlay = currentPlay;
                    else if (!cIT && !wIT && currentCard.suit === trickSuit && cRV > wRV) winningPlay = currentPlay;
                }
            }
            return winningPlay;
       }

        // --- Мултиплейър Функции ---
        function initializeMultiplayerElements() { roleSelectionEl=document.getElementById('role-selection'); playerNameInputEl=document.getElementById('player-name-input'); becomeHostBtnEl=document.getElementById('become-host-btn'); becomeGuestBtnEl=document.getElementById('become-guest-btn'); hostPanelEl=document.getElementById('host-panel'); hostPeerIdDisplayEl=document.getElementById('host-peer-id-display'); copyHostIdBtnEl=document.getElementById('copy-host-id-btn'); connectedGuestsCountEl=document.getElementById('connected-guests-count'); guestListEl=document.getElementById('guest-list'); mpStartGameBtnEl=document.getElementById('mp-start-game-btn'); guestPanelEl=document.getElementById('guest-panel'); hostIdInputEl=document.getElementById('host-id-input'); connectToHostBtnEl=document.getElementById('connect-to-host-btn'); mpConnectionStatusEl=document.getElementById('mp-connection-status'); if(!becomeHostBtnEl||!becomeGuestBtnEl||!connectToHostBtnEl||!mpStartGameBtnEl||!copyHostIdBtnEl){console.error("MP Buttons missing!");if(mpConnectionStatusEl)mpConnectionStatusEl.textContent="Грешка UI MP.";return;} becomeHostBtnEl.onclick=setupHostPeerJS; becomeGuestBtnEl.onclick=setupGuestPeerJS; connectToHostBtnEl.onclick=connectToHost; mpStartGameBtnEl.onclick=()=>{if(isHost&&connectedGuestsCount===3){assignPlayerPositionsAndStart();}}; copyHostIdBtnEl.onclick=()=>{if(myPeerId&&navigator.clipboard){navigator.clipboard.writeText(myPeerId).then(()=>alert("Peer ID копиран!")).catch(err=>{console.error('Copy failed: ',err);prompt("Копирайте ръчно:",myPeerId);});}else if(myPeerId){prompt("Копирайте ръчно:",myPeerId);}}; }
        function setupHostPeerJS() { myPlayerName=playerNameInputEl.value.trim()||`Хост${Math.floor(Math.random()*100)}`; if(!myPlayerName){alert("Въведете име.");return;} isHost=!0; gameMode='MULTIPLAYER_HOST'; roleSelectionEl.style.display='none'; hostPanelEl.style.display='block'; mpConnectionStatusEl.textContent="Инициализация PeerJS..."; peer=new Peer(); peer.on('open',id=>{myPeerId=id;playerNames[myPeerId]=myPlayerName;console.log('Host PeerID:',myPeerId);hostPeerIdDisplayEl.textContent=myPeerId;mpConnectionStatusEl.textContent=`Стая: ${myPeerId}. Чакане...`;}); peer.on('connection',conn=>{if(connectedGuestsCount>=3){console.warn("Max guests. Rejecting",conn.peer);conn.send({type:"ERROR",message:"Стаята пълна."});setTimeout(()=>conn.close(),500);return;} console.log('Guest trying to connect:',conn.peer);guestConnections[conn.peer]=conn;connectedGuestsCount++;connectedGuestsCountEl.textContent=connectedGuestsCount;const li=document.createElement('li');li.id=`guest-${conn.peer}`;li.textContent=`Гост ${conn.peer} (свързване...)`;guestListEl.appendChild(li);mpConnectionStatusEl.textContent=`${connectedGuestsCount}/3 гости.`;if(connectedGuestsCount===3){mpStartGameBtnEl.disabled=!1;mpConnectionStatusEl.textContent="Всички свързани! Старт от хоста.";} setupPeerDataEvents(conn,conn.peer);}); peer.on('error',err=>{console.error('PeerJS Host Error:',err); alert(`PeerJS Грешка: ${err.message || err.type}`);}); peer.on('disconnected',()=>{mpConnectionStatusEl.textContent="PeerJS сървър прекъснат.";});}
        function setupGuestPeerJS() { myPlayerName=playerNameInputEl.value.trim()||`Гост${Math.floor(Math.random()*100)}`; if(!myPlayerName){alert("Въведете име.");return;} isHost=!1; gameMode='MULTIPLAYER_GUEST'; roleSelectionEl.style.display='none'; guestPanelEl.style.display='block'; mpConnectionStatusEl.textContent="Въведете код на стая.";}
        function connectToHost() { const hostId=hostIdInputEl.value.trim(); if(!hostId){alert("Въведете код.");return;} mpConnectionStatusEl.textContent=`Свързване към ${hostId}...`; if(peer)peer.destroy(); peer=new Peer(); peer.on('open',id=>{myPeerId=id;playerNames[myPeerId]=myPlayerName;console.log('Guest PeerID:',myPeerId,"Connecting to:",hostId);const conn=peer.connect(hostId,{reliable:!0});hostConnection=conn;setupPeerDataEvents(conn,hostId);}); peer.on('error',err=>{mpConnectionStatusEl.textContent=`Грешка свързване: ${err.type}`;console.error(err);});}
        function setupPeerDataEvents(conn,remotePeerId){conn.on('open',()=>{console.log(`Data conn OPEN with ${remotePeerId}`);if(isHost){const li=document.getElementById(`guest-${remotePeerId}`);if(li)li.textContent=`Гост ${remotePeerId} (свързан)`;conn.send({type:"HANDSHAKE_REQUEST",hostName:myPlayerName,hostPeerId:myPeerId});}else{mpConnectionStatusEl.textContent=`Свързан с Хост ${remotePeerId}.`;}}); conn.on('data',data=>{console.log(`Data from ${remotePeerId}:`,data);if(data.type==="HANDSHAKE_REQUEST"&&!isHost){playerNames[data.hostPeerId]=data.hostName;conn.send({type:"HANDSHAKE_RESPONSE",guestName:myPlayerName,guestPeerId:myPeerId});setMessage(`Свързан с хост ${data.hostName}. Чакане...`);}else if(data.type==="HANDSHAKE_RESPONSE"&&isHost){playerNames[data.guestPeerId]=data.guestName;const li=document.getElementById(`guest-${data.guestPeerId}`);if(li)li.textContent=`Гост: ${data.guestName} (${data.guestPeerId})`;}else{handleNetworkMessage(data,remotePeerId);}}); conn.on('close',()=>{console.log(`Data conn CLOSED with ${remotePeerId}`);mpConnectionStatusEl.textContent=`Връзка с ${remotePeerId} прекъсната.`;if(isHost){delete guestConnections[remotePeerId];delete playerNames[remotePeerId];delete playerPeerIds[Object.keys(playerPeerIds).find(pos => playerPeerIds[pos] === remotePeerId)]; connectedGuestsCount--;connectedGuestsCountEl.textContent=connectedGuestsCount;const li=document.getElementById(`guest-${remotePeerId}`);if(li)li.remove();if(connectedGuestsCount<3)mpStartGameBtnEl.disabled=!0;broadcastToGuests({type:"PLAYER_LEFT",peerId:remotePeerId},remotePeerId);}else{alert("Връзка с хоста прекъсната!");roleSelectionEl.style.display='block';guestPanelEl.style.display='none';hostPanelEl.style.display='none';if(mpStartGameBtnEl)mpStartGameBtnEl.disabled=!0; if(gameContainerEl) gameContainerEl.style.display='none';}}); conn.on('error',err=>{console.error(`PeerJS Conn Error with ${remotePeerId}:`,err);mpConnectionStatusEl.textContent=`Грешка връзка с ${remotePeerId}.`;});}
        function broadcastToAll(data){if(isHost){broadcastToGuests(data);handleNetworkMessage(data,myPeerId);}else{console.warn("Guests cannot broadcast.");}}
        function broadcastToGuests(data,excludePeerId=null){if(!isHost)return;console.log("Broadcasting to guests:",data,"Excluding:",excludePeerId);for(const pId in guestConnections){if(pId!==excludePeerId){if(guestConnections[pId]&&guestConnections[pId].open){guestConnections[pId].send(data);}}}}
        function sendToHost(data){if(isHost||!hostConnection||!hostConnection.open){console.warn("Cannot send to host.");return;}console.log("Sending to host:",data);hostConnection.send(data);}
        function assignPlayerPositionsAndStart(){if(!isHost||connectedGuestsCount!==3)return;const guestPIds=Object.keys(guestConnections);playerPositions={S:null,W:null,N:null,E:null};playerPeerIds={};playerPositions['S']=myPeerId;playerPeerIds[myPeerId]='S';playerPositions['W']=guestPIds[0];playerPeerIds[guestPIds[0]]='W';playerPositions['N']=guestPIds[1];playerPeerIds[guestPIds[1]]='N';playerPositions['E']=guestPIds[2];playerPeerIds[guestPIds[2]]='E';console.log("Positions:",playerPositions);const posNames={};PLAYERS.forEach(pos=>{const pId=playerPositions[pos];posNames[pos]=playerNames[pId]||`Играч (${pos})`;const nEl=playerAreaEls[pos]?.querySelector('.player-name');if(nEl)nEl.textContent=posNames[pos]+(pos===myPosition?" (Вие)":"");});if(gameContainerEl)gameContainerEl.style.display='flex';if(declaredAnnouncementsDisplayEl)declaredAnnouncementsDisplayEl.style.display='block';if(scoreBoardEl)scoreBoardEl.style.display='block';const connSetupEl=document.querySelector('.connection-setup');if(connSetupEl)connSetupEl.style.display='none';currentDealer='S';const initData={type:"GAME_START_INFO",playerPositions:playerPositions,playerNames:posNames,currentDealer:currentDealer,myPositionForGuest:null};for(const gPId in guestConnections){const gPos=playerPeerIds[gPId];const dataForG={...initData,myPositionForGuest:gPos};sendGameDataToSpecificGuest(gPId,dataForG);} handleNetworkMessage({...initData,myPositionForGuest:'S'},myPeerId);gameState='LOBBY';mpStartGameBtnEl.textContent = "Старт на Рунд"; mpStartGameBtnEl.onclick = startGame; startGame();} // Хостът стартира първия рунд
        function sendGameDataToSpecificGuest(gPId,data){if(isHost&&guestConnections[gPId]&&guestConnections[gPId].open){console.log(`Sending to guest ${gPId}:`,data);guestConnections[gPId].send(data);}else{console.warn(`Cannot send to guest ${gPId}.`);}}
                function handleNetworkMessage(message, fromPeerId) { // fromPeerId е ID-то на изпращача
            console.log(`Received P2P message of type ${message.type} from ${getPlayerName(playerNames[playerPeerIds[fromPeerId]] || fromPeerId)} (${fromPeerId}):`, message);

            // Ръкостискане за имена - вече би трябвало да е обработено в setupPeerDataEvents
            if (message.type === "HANDSHAKE_RESPONSE" && isHost) {
                // Тази логика е преместена в setupPeerDataEvents, но я оставям за всеки случай, ако има пропуск
                if (!playerNames[message.guestPeerId]) { // Само ако името не е вече зададено
                    playerNames[message.guestPeerId] = message.guestName;
                    const guestListItem = document.getElementById(`guest-${message.guestPeerId}`);
                    if(guestListItem) guestListItem.textContent = `Гост: ${message.guestName} (${message.guestPeerId})`;
                }
                return;
            }


            switch (message.type) {
                case "GAME_START_INFO":
                    playerPositions = message.playerPositions; // {S: peerId, W: peerId, ...}
                    playerNames = message.playerNames;         // {S: "Име1", W: "Име2", ...}
                    currentDealer = message.currentDealer;
                    myPosition = isHost ? 'S' : message.myPositionForGuest; // Гостът получава своята позиция

                    // Създаваме playerPeerIds за лесен достъп от позиция към peerId и обратно
                    playerPeerIds = {};
                    for(const pos in playerPositions) {
                        playerPeerIds[playerPositions[pos]] = pos;
                    }

                    console.log("My determined position:", myPosition);
                    console.log("All player names by position:", playerNames);
                    console.log("Player Peer IDs by position:", playerPeerIds);


                    // Обновяване на имената в UI
                    PLAYERS.forEach(pos => {
                        const nameEl = playerAreaEls[pos]?.querySelector('.player-name');
                        if (nameEl) {
                            let displayName = playerNames[pos] || `Играч (${pos})`;
                            if (pos === myPosition) displayName += " (Вие)";
                            nameEl.textContent = displayName;
                        }
                    });

                    if(gameContainerEl) gameContainerEl.style.display = 'flex';
                    if(declaredAnnouncementsDisplayEl) declaredAnnouncementsDisplayEl.style.display = 'block';
                    if(scoreBoardEl) scoreBoardEl.style.display = 'block';
                    const connectionSetupEl = document.querySelector('.connection-setup');
                    if (connectionSetupEl) connectionSetupEl.style.display = 'none';

                    if (!isHost) {
                        setMessage("Играта започва! Изчаква се хостът да раздаде картите...");
                    } else {
                        // Хостът вече е извикал startGame(), което ще извика dealInitialCards()
                        setMessage("Играта започна! Вие сте раздаващ (или който е ред).");
                    }
                    break;

                case "DEAL_CARDS_PHASE1":
                    hands = message.hands; // Всички получават всички ръце
                    currentDealer = message.dealer;
                    gameState = 'BIDDING';
                    sortHands();
                    renderAllHands(); // Всеки вижда своята ръка, другите са скрити
                    startBidding();   // Всички стартират наддаването
                    break;

                case "DEAL_CARDS_PHASE2":
                    hands = message.hands;
                    potentialAnnouncements = message.potentialAnnouncements;
                    gameState = 'PLAYING';
                    sortHands();
                    renderAllHands();
                    currentPlayer = getNextPlayer(currentDealer); // Хостът е задал това
                    updatePersistentTrumpInfo(); // Уверяваме се, че козът е показан правилно
                    startPlayingPhase();
                    break;

                case "PLAYER_BID": // Само хостът получава това
                    if (isHost) {
                        const bidderPosition = playerPeerIds[fromPeerId]; // Намираме позицията на госта
                        if (bidderPosition && bidderPosition === currentPlayer) {
                            console.log(`Host processing PLAYER_BID from ${getPlayerName(playerNames[bidderPosition] || bidderPosition)} (${bidderPosition}), bid: ${message.bid}`);
                            handleBid(bidderPosition, message.bid); // Хостът обработва наддаването
                        } else {
                            console.warn("Host received BID from wrong player or unknown peerId:", fromPeerId, "Expected:", currentPlayer);
                        }
                    }
                    break;

                case "BID_UPDATE": // Всички получават това
                    currentBid = message.currentHighestBid;
                    biddingHistory = message.biddingHistory;
                    if (message.bidMade !== 'PASS') updatePersistentTrumpInfo();
                    setMessage(`${getPlayerName(playerNames[message.biddingPlayer] || message.biddingPlayer)} наддаде ${BID_NAMES[message.bidMade]}`);
                    break;

                case "NEXT_BIDDER": // Всички получават това
                    currentPlayer = message.nextPlayer;
                    setMessage(`Наддаване: Ред на ${getPlayerName(playerNames[currentPlayer] || currentPlayer)}`);
                    updateCurrentPlayerHighlight();
                    updateBiddingControls();
                    break;

                case "BIDDING_END": // Всички получават това
                    currentBid = message.finalBid;
                    finalizeBidding(); // Тази ще извика dealFinalCards при хоста, ако е нужно
                    break;

                case "PLAYER_ANNOUNCEMENTS": // Само хостът получава това
                    if (isHost) {
                        const announcerPosition = message.playerPos; // Това е позицията на играча, не peerId
                        declaredAnnouncements[announcerPosition] = message.announcements;
                        console.log(`Host received announcements from ${getPlayerName(playerNames[announcerPosition]||announcerPosition)}:`, message.announcements);
                        updateDeclaredAnnouncementsDisplay();
                        // Препращаме анонсите на ДРУГИТЕ гости
                        broadcastToGuests({
                            type: "ANNOUNCEMENT_DECLARED",
                            playerPos: announcerPosition,
                            announcements: message.announcements
                        }, playerPositions[announcerPosition]); // Изключваме изпращача
                    }
                    break;

                case "ANNOUNCEMENT_DECLARED": // Гостите (и хостът, ако е препратено на него) получават това
                    declaredAnnouncements[message.playerPos] = message.announcements;
                    updateDeclaredAnnouncementsDisplay();
                    if(message.belotDeclaredMessage) setMessage(message.belotDeclaredMessage);
                    break;

                case "PLAY_CARD": // Само хостът получава това
                    if (isHost) {
                        const playerPosition = playerPeerIds[fromPeerId]; // Намираме позицията на госта
                        if (playerPosition && playerPosition === currentPlayer) {
                            console.log(`Host processing PLAY_CARD from ${getPlayerName(playerNames[playerPosition] || playerPosition)} (${playerPosition}), card: ${message.cardId}`);
                            processPlayedCard(playerPosition, message.cardId); // Хостът обработва и изпраща CARD_PLAYED
                        } else {
                             console.warn("Host received PLAY_CARD from wrong player or unknown peerId:", fromPeerId, "Expected:", currentPlayer);
                        }
                    }
                    break;

                case "CARD_PLAYED": // Всички получават това
                    console.log(`Processing CARD_PLAYED for ${message.playerPos}, card: ${message.card?.id}`);
                    currentTrick = message.currentTrick;
                    if (hands[message.playerPos] && message.card) {
                        hands[message.playerPos] = hands[message.playerPos].filter(c => c.id !== message.card.id);
                    }
                    renderHand(message.playerPos);
                    renderTrickArea();

                    if (message.belotInfo) {
                        belotStatus[message.belotInfo.playerPos].declared = true;
                        const belotAnnObject = potentialAnnouncements[message.belotInfo.playerPos]?.find(a => a.type === 'BELOT');
                        if (belotAnnObject && !declaredAnnouncements[message.belotInfo.playerPos].some(a => a.type === 'BELOT')) {
                            declaredAnnouncements[message.belotInfo.playerPos].push(belotAnnObject);
                        }
                        updateDeclaredAnnouncementsDisplay();
                        setMessage(message.belotInfo.message);
                    }

                    // Хостът инициира преминаването към следващ играч, ако той е изиграл картата
                    if (isHost && message.playerPos === playerPeerIds[fromPeerId]) { // Проверяваме дали fromPeerId е този, който е играл
                        moveToNextPlayerInTrick();
                    }
                    // Ако хостът е играл и това е съобщението за неговия ход (изпратено чрез broadcastToAll)
                    else if (isHost && message.playerPos === myPosition && fromPeerId === myPeerId) {
                        moveToNextPlayerInTrick();
                    }
                    // Гостите просто актуализират и чакат NEXT_PLAYER_TRICK или TRICK_RESULT
                    break;

                case "NEXT_PLAYER_TRICK": // Всички получават това
                    currentPlayer = message.nextPlayer;
                    setMessage(`Игра: Ред ${getPlayerName(playerNames[currentPlayer] || currentPlayer)}.`);
                    updateCurrentPlayerHighlight();
                    preparePlayerTurn(); // Това ще покаже модал за анонс, ако е първа ръка за играча
                    break;

                case "TRICK_RESULT": // Всички получават това
                    roundScores = message.roundScores;
                    setMessage(`${getPlayerName(playerNames[message.winner] || message.winner)} печели с ${cardToString(message.winningCard)}. Точки: ${message.points}${message.isLastTrick?' (+10)':''}`);
                    trickHistory.push({winner:message.winner, trick:currentTrick, points:message.points});
                    setTimeout(()=>{
                        clearTrickArea();
                        if(message.isLastTrick){
                             if(isHost) endRound(); // Само хостът изчислява края на рунда
                             // Гостите чакат ROUND_END_INFO
                        } else {
                            currentPlayer = message.winner; // Победителят започва
                            // Хостът вече е изпратил (или ще изпрати) NEXT_PLAYER_TRICK
                            // Всички локално стартират следващата ръка, когато получат NEXT_PLAYER_TRICK
                            // gameState='PLAYING'; // Това се задава от startPlayingPhase
                            // startPlayingPhase(); // Това ще се извика при NEXT_PLAYER_TRICK
                        }
                    }, 1800);
                    break;

                case "ROUND_END_INFO": // Гостите получават това
                    if (!isHost) {
                        teamScores = message.teamScores;
                        updateScoreBoard();
                        setMessage(message.message); // Пълното съобщение от хоста
                        if (message.nextDealer) {
                            currentDealer = message.nextDealer;
                            if (message.startNextRound) {
                                 setMessage("Изчаква се хостът да стартира следващия рунд...");
                                 // Гостът е готов за следващия рунд, но хостът го инициира
                            }
                        }
                    }
                    break;

                case "GAME_OVER_INFO": // Гостите получават това
                    if (!isHost) {
                        gameState = 'GAME_OVER';
                        teamScores = message.teamScores;
                        updateScoreBoard();
                        setMessage(message.message);
                        // Показваме отново панела за избор на роля, за да може да се започне нова игра
                        if(roleSelectionEl) roleSelectionEl.style.display = 'block';
                        if(hostPanelEl) hostPanelEl.style.display = 'none';
                        if(guestPanelEl) guestPanelEl.style.display = 'none';
                        if(gameContainerEl) gameContainerEl.style.display = 'none';
                        if(declaredAnnouncementsDisplayEl) declaredAnnouncementsDisplayEl.style.display = 'none';
                        if(scoreBoardEl) scoreBoardEl.style.display = 'none';
                        if(mpStartGameBtnEl) mpStartGameBtnEl.disabled = true; // Нулиране на бутона на хоста
                    }
                    break;

                case "PLAYER_LEFT":
                    const leftPlayerName = playerNames[playerPeerIds[message.peerId]] || message.peerId;
                    alert(`Играч ${leftPlayerName} напусна играта.`);
                    // TODO: По-добро управление на напускане - спиране на играта, нулиране на UI
                    // Засега просто показваме съобщение и хостът не може да стартира
                    if(isHost) {
                        const guestListItem = document.getElementById(`guest-${message.peerId}`);
                        if(guestListItem) guestListItem.textContent += " (Напусна)";
                        if(mpStartGameBtnEl) mpStartGameBtnEl.disabled = true;
                        connectedGuestsCount = Object.keys(guestConnections).length;
                        if(connectedGuestsCountEl) connectedGuestsCountEl.textContent = connectedGuestsCount;
                    }
                    // Може да се върне към лоби екрана
                    if (gameMode.startsWith("MULTIPLAYER")) {
                        gameState = 'LOBBY';
                        // Нулиране на UI до лоби
                        if(roleSelectionEl) roleSelectionEl.style.display = 'block';
                        if(hostPanelEl) hostPanelEl.style.display = 'none';
                        if(guestPanelEl) guestPanelEl.style.display = 'none';
                        if(gameContainerEl) gameContainerEl.style.display = 'none';
                        if(declaredAnnouncementsDisplayEl) declaredAnnouncementsDisplayEl.style.display = 'none';
                        if(scoreBoardEl) scoreBoardEl.style.display = 'none';
                        if(mpConnectionStatusEl) mpConnectionStatusEl.textContent = "Играч напусна. Изберете роля отново.";
                        if(peer && !isHost) peer.destroy(); // Гостът унищожава своята PeerJS инстанция
                        if(peer && isHost && connectedGuestsCount === 0) peer.destroy(); // Хостът унищожава, ако няма гости
                    }
                    break;

                default:
                    console.warn("Unknown message type received:", message.type);
            }
        } // Край на handleNetworkMessage

        function sendToHostOrBroadcast(data) { if(gameMode==='MULTIPLAYER_GUEST'){sendToHost(data);}else if(gameMode==='MULTIPLAYER_HOST'){broadcastToAll(data);}}

        // --- Инициализация ---
        function startGame() {
            console.log("startGame function entered! GameMode:", gameMode, "IsHost:", isHost);
            if (!messagesEl) { console.error("startGame: messagesEl not ready!"); return; }
            setMessage("Подготовка за нов рунд...");
            if (gameMode.startsWith('MULTIPLAYER') && mpStartGameBtnEl) { mpStartGameBtnEl.disabled = true; }

            gameState = 'INIT_ROUND'; // Ново състояние за начало на рунд
            clearCurrentPlayerHighlight();
            hideBiddingControls();
            hideAnnouncementModal();
            if(declaredAnnouncementsDisplayEl) declaredAnnouncementsDisplayEl.style.display = 'block';
            if(declaredAnnouncementsListEl) declaredAnnouncementsListEl.innerHTML = 'Няма обявени анонси в този рунд.';
            trickHistory = []; currentTrick = [];
            potentialAnnouncements = {S:[],W:[],N:[],E:[]}; declaredAnnouncements = {S:[],W:[],N:[],E:[]};
            playerDeclaredFlags = {S:!1,W:!1,N:!1,E:!1};
            belotStatus = {S:{hasKQ:!1,declared:!1},W:{hasKQ:!1,declared:!1},N:{hasKQ:!1,declared:!1},E:{hasKQ:!1,declared:!1}};
            roundScores = {NS:{points:0,announcements:0},EW:{points:0,announcements:0}};

            if (isHost || gameMode === 'LOCAL') {
                try {
                    console.log("startGame (Host/Local): Initializing round state...");
                    createDeck(); shuffleDeck(); cutDeck();
                    dealInitialCards(); // Тази ще изпрати DEAL_CARDS_PHASE1
                    // updateScoreBoard(); // Не нулираме общия резултат тук, само при нова игра
                } catch (error) { console.error("CRITICAL Error during round initialization:", error); setMessage(`Грешка: ${error.message}.`); if (gameMode.startsWith('MULTIPLAYER') && mpStartGameBtnEl) mpStartGameBtnEl.disabled = false; return; }
                console.log("startGame (Host/Local) round init finished successfully.");
            } else {
                console.log("startGame (Guest): Waiting for host to deal cards for new round.");
                setMessage("Изчаква се хостът да раздаде картите за новия рунд...");
            }
        }


        // --- Event Listeners и Първоначално състояние ---
         document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded and parsed (v7.0)");
            persistentTrumpInfoEl = document.getElementById('persistent-trump-info');
            playerAreaEls = { S: document.getElementById('player-area-S'), W: document.getElementById('player-area-W'), N: document.getElementById('player-area-N'), E: document.getElementById('player-area-E') };
            playerHands = { S: document.getElementById('hand-S'), W: document.getElementById('hand-W'), N: document.getElementById('hand-N'), E: document.getElementById('hand-E') };
            trickAreaEl = document.getElementById('trick-area');
            trickCardSlots = { S: document.getElementById('trick-slot-S'), W: document.getElementById('trick-slot-W'), N: document.getElementById('trick-slot-N'), E: document.getElementById('trick-slot-E') };
            controlsAreaEl = document.getElementById('controls-area');
            controlsButtonsEl = document.getElementById('controls-buttons');
            declaredAnnouncementsDisplayEl = document.getElementById('declared-announcements-display');
            declaredAnnouncementsListEl = document.getElementById('declared-announcements-list');
            messagesEl = document.getElementById('messages');
            scoreBoardEl = document.getElementById('score-board');
            announcementModal = document.getElementById('announcementModal');
            modalAnnouncementsList = document.getElementById('modal-announcement-list');
            modalConfirmBtn = document.getElementById('modal-confirm-btn');
            gameContainerEl = document.querySelector('.game-container');

            initializeMultiplayerElements();
            console.log("DOM elements assigned.");

            const criticalDOMElements = [persistentTrumpInfoEl, playerAreaEls.S, playerHands.S, trickAreaEl, trickCardSlots.S, controlsAreaEl, controlsButtonsEl, declaredAnnouncementsDisplayEl, declaredAnnouncementsListEl, messagesEl, scoreBoardEl, announcementModal, modalAnnouncementsList, modalConfirmBtn, roleSelectionEl, playerNameInputEl, becomeHostBtnEl, becomeGuestBtnEl, hostPanelEl, hostPeerIdDisplayEl, copyHostIdBtnEl, connectedGuestsCountEl, guestListEl, mpStartGameBtnEl, guestPanelEl, hostIdInputEl, connectToHostBtnEl, mpConnectionStatusEl, gameContainerEl];
            let missingElement = false;
            criticalDOMElements.forEach(el => { if (!el) missingElement = true; });
            if (missingElement) { console.error("One or more critical DOM elements NOT FOUND!"); alert("Грешка: Не всички елементи на играта са заредени! Презаредете."); return; }

            setMessage("Изберете роля (Хост/Гост).");
            updateScoreBoard(); renderAllHands(); clearCurrentPlayerHighlight();
            updatePersistentTrumpInfo(); hideBiddingControls();
            if(declaredAnnouncementsDisplayEl) declaredAnnouncementsDisplayEl.style.display = 'none';
            if(scoreBoardEl) scoreBoardEl.style.display = 'none';
            if(gameContainerEl) gameContainerEl.style.display = 'none';
            console.log("Initial setup complete.");
        });

    </script>
</body>
</html>
